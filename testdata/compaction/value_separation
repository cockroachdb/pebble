# Test a simple sequence of flushes and compactions where all values are
# separated.

define value-separation=(true, 1, 3, 0, 1.0)
----

batch
set a 1
set b 2
----

compact a-b
----
L6:
  000005:[a#10,SET-b#11,SET] seqnums:[10-11] points:[a#10,SET-b#11,SET] size:751 blobrefs:[(B000006: 2); depth:1]
Blob files:
  B000006 physical:{000006 size:[92 (92B)] vals:[2 (2B)]}

batch
set c 3
set d 4
----

compact c-d
----
L6:
  000005:[a#10,SET-b#11,SET] seqnums:[10-11] points:[a#10,SET-b#11,SET] size:751 blobrefs:[(B000006: 2); depth:1]
  000008:[c#12,SET-d#13,SET] seqnums:[12-13] points:[c#12,SET-d#13,SET] size:751 blobrefs:[(B000009: 2); depth:1]
Blob files:
  B000006 physical:{000006 size:[92 (92B)] vals:[2 (2B)]}
  B000009 physical:{000009 size:[92 (92B)] vals:[2 (2B)]}

batch
set b 5
set c 6
----

compact a-d
----
L6:
  000013:[a#0,SET-d#0,SET] seqnums:[0-0] points:[a#0,SET-d#0,SET] size:789 blobrefs:[(B000006: 1), (B000012: 2), (B000009: 1); depth:2]
Blob files:
  B000006 physical:{000006 size:[92 (92B)] vals:[2 (2B)]}
  B000009 physical:{000009 size:[92 (92B)] vals:[2 (2B)]}
  B000012 physical:{000012 size:[92 (92B)] vals:[2 (2B)]}

batch
del-range a e
----

compact a-d
----

# Set up a scenario where there's a L6 sstable with a blob reference depth of 3,
# and the value separation policy is configured to limit the blob reference
# depth to 3.

define verbose value-separation=(true, 3, 3, 0s, 1.0)
L6 blob-depth=3
  a.SET.0:a
  b.SET.0:blob{fileNum=100002 value=bar}
  f.SET.0:blob{fileNum=100003 value=foo}
  k.SET.0:k
  z.SET.0:blob{fileNum=100004 value=zoo}
----
L6:
  000004:[a#0,SET-z#0,SET] seqnums:[0-0] points:[a#0,SET-z#0,SET] size:791 blobrefs:[(B100002: 3), (B100003: 3), (B100004: 3); depth:3]
Blob files:
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}

batch
set d hello
set e world
----

# Flush should write flushed values to a new blob file.

flush
----
L0.0:
  000006:[d#10,SET-e#11,SET] seqnums:[10-11] points:[d#10,SET-e#11,SET] size:750 blobrefs:[(B000007: 10); depth:1]
L6:
  000004:[a#0,SET-z#0,SET] seqnums:[0-0] points:[a#0,SET-z#0,SET] size:791 blobrefs:[(B100002: 3), (B100003: 3), (B100004: 3); depth:3]
Blob files:
  B000007 physical:{000007 size:[100 (100B)] vals:[10 (10B)]}
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}

# Compacting these two sstables should result in writing the values to a new
# blob file and the removal of the no longer referenced blob files.

compact a-z
----
L6:
  000008:[a#0,SET-z#0,SET] seqnums:[0-0] points:[a#0,SET-z#0,SET] size:801 blobrefs:[(B000009: 19); depth:1]
Blob files:
  B000009 physical:{000009 size:[112 (112B)] vals:[19 (19B)]}

# Ensure we can read the separated values by iterating over the database.

iter
first
next
next
next
next
next
next
----
a: (a, .)
b: (bar, .)
d: (hello, .)
e: (world, .)
f: (foo, .)
k: (k, .)
z: (zoo, .)

metrics
----
----
LSM                             |    vtables   |   value sep   |        |   ingested   |    amp
level       size | tables  size |  count  size |  refsz valblk |     in | tables  size |   r     w
-----------------+--------------+--------------+---------------+--------+--------------+----------
    0         0B |      0    0B |      0     0 |     0B     0B |    41B |      0    0B |   0 23.17
    1         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    2         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    3         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    4         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    5         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    6       913B |      1  801B |      0     0 |   112B     0B |   750B |      0    0B |   1  1.22
total       913B |      1  801B |      0     0 |   112B     0B |    41B |      0    0B |   1 46.44

COMPACTIONS               |     moved    |     multilevel    |     read     |       written
level | score    ff   cff | tables  size |   top    in  read | tables  blob | tables  sstsz blobsz
------+-------------------+--------------+-------------------+--------------+---------------------
    0 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      1   750B   200B
    1 |     -     0     0 |      1  750B |    0B    0B    0B |     0B    0B |      0     0B     0B
    2 |     -     0     0 |      1  750B |    0B    0B    0B |     0B    0B |      0     0B     0B
    3 |     -     0     0 |      1  750B |    0B    0B    0B |     0B    0B |      0     0B     0B
    4 |     -     0     0 |      1  750B |    0B    0B    0B |     0B    0B |      0     0B     0B
    5 |     -     0     0 |      1  750B |    0B    0B    0B |     0B    0B |      0     0B     0B
    6 |     -  0.00  0.00 |      0    0B |    0B    0B    0B |   372B   84B |      1   801B   112B
total |     -     -     - |      5 3.7KB |    0B    0B    0B |   372B   84B |      2  1.6KB   312B

 kind | default  delete  elision  move  read  tomb  rewrite  copy  multi  blob
count |       1       0        0     5     0     0        0     0      0     0

COMMIT PIPELINE
               wals                |              memtables              |       ingestions
    files |    written |  overhead |   flushes |       live |     zombie |     total |   flushable
----------+------------+-----------+-----------+------------+------------+-----------+------------
   1 (0B) |   30B: 41B |     36.7% |         1 |  1 (256KB) |  1 (256KB) |        71 |      0 (0B)

ITERATORS
        block cache        |         file cache         |    filter    |  sst iters  |  snapshots
     entries |    hit rate |      entries |    hit rate |         util |        open |        open
-------------+-------------+--------------+-------------+--------------+-------------+------------
   5 (1.8KB) |       81.8% |     1 (392B) |       89.2% |         0.0% |           0 |           0

FILES                 tables                       |       blob files        |     blob values
   stats prog |    backing |                zombie |       live |     zombie |  total |      refed
--------------+------------+-----------------------+------------+------------+--------+-----------
   all loaded |     0 (0B) |       0 (0B local:0B) |   1 (112B) |     0 (0B) |    19B | 100% (19B)

CGO MEMORY    |          block cache           |                     memtables
          tot |           tot |           data |            maps |            ents |           tot
--------------+---------------+----------------+-----------------+-----------------+--------------
           0B |            0B |             0B |              0B |              0B |            0B

COMPACTIONS
   estimated debt |       in progress |         cancelled |            failed |      problem spans
------------------+-------------------+-------------------+-------------------+-------------------
               0B |            0 (0B) |            0 (0B) |                 0 |                  0

KEYS
      range keys |       tombstones |      missized tombstones |      point dels |      range dels
-----------------+------------------+--------------------------+-----------------+----------------
               0 |                0 |                        0 |              0B |              0B

COMPRESSION
    algorithm | none  snappy
on disk bytes |  56B    134B
           CR |         1.15
----
----

# Set the minimum size for a separated value to 5.

define value-separation=(true, 5, 3, 0s, 1.0)
----

batch
set bar bar
set foo foo
set fuzz fuzz
set yaya yaya
----

# The flush should not write a blob file because none of the keys have a
# sufficiently long value to be separated.

flush
----
L0.0:
  000005:[bar#10,SET-yaya#13,SET] seqnums:[10-13] points:[bar#10,SET-yaya#13,SET] size:686

batch
set a a
set b b
set h hello
set w world
----

# This flush *should* write a blob file, containing 2 values: "hello" and
# "world" totaling 10 bytes of logical values.

flush
----
L0.1:
  000007:[a#14,SET-w#17,SET] seqnums:[14-17] points:[a#14,SET-w#17,SET] size:779 blobrefs:[(B000008: 10); depth:1]
L0.0:
  000005:[bar#10,SET-yaya#13,SET] seqnums:[10-13] points:[bar#10,SET-yaya#13,SET] size:686
Blob files:
  B000008 physical:{000008 size:[100 (100B)] vals:[10 (10B)]}

get
a
b
h
w
----
a:a
b:b
h:hello
w:world

batch
set yay@3 a
set yay@2 ab
set zoo@3 b
set zoo@2 ba
----

# This flush *should* write a blob file for our MVCC garbage values, containing
# 2 values: "ab" and "ba" - totaling 4 bytes of logical values.

flush
----
L0.1:
  000007:[a#14,SET-w#17,SET] seqnums:[14-17] points:[a#14,SET-w#17,SET] size:779 blobrefs:[(B000008: 10); depth:1]
  000010:[yay@3#18,SET-zoo@2#21,SET] seqnums:[18-21] points:[yay@3#18,SET-zoo@2#21,SET] size:803 blobrefs:[(B000011: 4); depth:1]
L0.0:
  000005:[bar#10,SET-yaya#13,SET] seqnums:[10-13] points:[bar#10,SET-yaya#13,SET] size:686
Blob files:
  B000008 physical:{000008 size:[100 (100B)] vals:[10 (10B)]}
  B000011 physical:{000011 size:[94 (94B)] vals:[4 (4B)]}

# Configure the database to require keys in the range [a,m) to be in-place.

define required-in-place=(a,m) value-separation=(true,1,3,0s,1.0)
----

batch
set a apple
set b banana
set c coconut
set d dragonfruit
set m mango
----

# The flush should write two sst files, and only "mango" should be separated. This
# should be reflected in the 5-byte value bytes of the blob file and the table's
# blob reference value size.

flush
----
L0.0:
  000005:[a#10,SET-d#13,SET] seqnums:[10-13] points:[a#10,SET-d#13,SET] size:704
  000006:[m#14,SET-m#14,SET] seqnums:[14-14] points:[m#14,SET-m#14,SET] size:747 blobrefs:[(B000007: 5); depth:1]
Blob files:
  B000007 physical:{000007 size:[94 (94B)] vals:[5 (5B)]}

# Construct an initial state with two overlapping files in L0, both with blob
# references. Because these files overlap and are in separate sublevels, a
# compaction that preserves blob references should sum their depths.

define value-separation=(true,1,5,0s,1.0) l0-compaction-threshold=2
L0 blob-depth=1
  a.SET.9:a
  d.SET.9:blob{fileNum=100001 value=d}
L0 blob-depth=3
  a.SET.1:a
  b.SET.1:blob{fileNum=100002 value=bar}
  f.SET.1:blob{fileNum=100003 value=foo}
  k.SET.1:k
  z.SET.1:blob{fileNum=100004 value=zoo}
----
L0.1:
  000004:[a#9,SET-d#9,SET] seqnums:[9-9] points:[a#9,SET-d#9,SET] size:760 blobrefs:[(B100001: 1); depth:1]
L0.0:
  000005:[a#1,SET-z#1,SET] seqnums:[1-1] points:[a#1,SET-z#1,SET] size:791 blobrefs:[(B100002: 3), (B100003: 3), (B100004: 3); depth:3]
Blob files:
  B100001 physical:{100001 size:[90 (90B)] vals:[1 (1B)]}
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}

compact a-z
----
L1:
  000006:[a#0,SET-z#0,SET] seqnums:[0-0] points:[a#0,SET-z#0,SET] size:810 blobrefs:[(B100002: 3), (B100001: 1), (B100003: 3), (B100004: 3); depth:4]
Blob files:
  B100001 physical:{100001 size:[90 (90B)] vals:[1 (1B)]}
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}

# Construct an initial state with two non-overlapping files in L0, both with
# blob references. Because these files do NOT overlap and are in the same
# sublevel, a compaction that preserves blob references should take the MAX of
# their depths.

define value-separation=(true,1,5,0s,1.0) l0-compaction-threshold=2
L0 blob-depth=1
  a.SET.9:a
  d.SET.9:blob{fileNum=100001 value=d}
L0 blob-depth=3
  e.SET.1:a
  f.SET.1:blob{fileNum=100002 value=bar}
  g.SET.1:blob{fileNum=100003 value=foo}
  k.SET.1:k
  z.SET.1:blob{fileNum=100004 value=zoo}
----
L0.0:
  000004:[a#9,SET-d#9,SET] seqnums:[9-9] points:[a#9,SET-d#9,SET] size:760 blobrefs:[(B100001: 1); depth:1]
  000005:[e#1,SET-z#1,SET] seqnums:[1-1] points:[e#1,SET-z#1,SET] size:791 blobrefs:[(B100002: 3), (B100003: 3), (B100004: 3); depth:3]
Blob files:
  B100001 physical:{100001 size:[90 (90B)] vals:[1 (1B)]}
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}

compact a-z
----
L1:
  000006:[a#0,SET-z#0,SET] seqnums:[0-0] points:[a#0,SET-z#0,SET] size:814 blobrefs:[(B100001: 1), (B100002: 3), (B100003: 3), (B100004: 3); depth:3]
Blob files:
  B100001 physical:{100001 size:[90 (90B)] vals:[1 (1B)]}
  B100002 physical:{100002 size:[92 (92B)] vals:[3 (3B)]}
  B100003 physical:{100003 size:[92 (92B)] vals:[3 (3B)]}
  B100004 physical:{100004 size:[92 (92B)] vals:[3 (3B)]}


# Configure a database with a minimum rewrite age of 0s (no delay) and a target
# garbage ratio of 0.0 (no garbage). With this configuration, any blob file that
# contains any unreferenced values should be immediately compacted.

define value-separation=(true,1,2,0s,0.0) auto-compactions=off
----

batch
set a apple
set b banana
set c coconut
set d dragonfruit
set e elderberry
set f fig
set g grapefruit
set h honeydew
----

flush
----
L0.0:
  000005:[a#10,SET-h#17,SET] seqnums:[10-17] points:[a#10,SET-h#17,SET] size:824 blobrefs:[(B000006: 60); depth:1]
Blob files:
  B000006 physical:{000006 size:[156 (156B)] vals:[60 (60B)]}

# Overwrite the value of the key 'c'.

batch
set c cherry
----

flush
----
L0.1:
  000008:[c#18,SET-c#18,SET] seqnums:[18-18] points:[c#18,SET-c#18,SET] size:747 blobrefs:[(B000009: 6); depth:1]
L0.0:
  000005:[a#10,SET-h#17,SET] seqnums:[10-17] points:[a#10,SET-h#17,SET] size:824 blobrefs:[(B000006: 60); depth:1]
Blob files:
  B000006 physical:{000006 size:[156 (156B)] vals:[60 (60B)]}
  B000009 physical:{000009 size:[95 (95B)] vals:[6 (6B)]}

# Compacting the two sstables will result in 'coconut' in the first blob file
# becoming unreferenced.

compact a-b
----
L6:
  000010:[a#0,SET-h#0,SET] seqnums:[0-0] points:[a#0,SET-h#0,SET] size:802 blobrefs:[(B000006: 53), (B000009: 6); depth:2]
Blob files:
  B000006 physical:{000006 size:[156 (156B)] vals:[60 (60B)]}
  B000009 physical:{000009 size:[95 (95B)] vals:[6 (6B)]}

auto-compact
----
L6:
  000010:[a#0,SET-h#0,SET] seqnums:[0-0] points:[a#0,SET-h#0,SET] size:802 blobrefs:[(B000006: 53), (B000009: 6); depth:2]
Blob files:
  B000006 physical:{000011 size:[150 (150B)] vals:[53 (53B)]}
  B000009 physical:{000009 size:[95 (95B)] vals:[6 (6B)]}

metrics
----
----
LSM                             |    vtables   |   value sep   |        |   ingested   |    amp
level       size | tables  size |  count  size |  refsz valblk |     in | tables  size |   r     w
-----------------+--------------+--------------+---------------+--------+--------------+----------
    0         0B |      0    0B |      0     0 |     0B     0B |   156B |      0    0B |   0 13.29
    1         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    2         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    3         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    4         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    5         0B |      0    0B |      0     0 |     0B     0B |     0B |      0    0B |   0     0
    6        1KB |      1  802B |      0     0 |   232B     0B |  1.5KB |      0    0B |   1  0.51
total        1KB |      1  802B |      0     0 |   232B     0B |   156B |      0    0B |   1 19.43

COMPACTIONS               |     moved    |     multilevel    |     read     |       written
level | score    ff   cff | tables  size |   top    in  read | tables  blob | tables  sstsz blobsz
------+-------------------+--------------+-------------------+--------------+---------------------
    0 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      2  1.5KB   502B
    1 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      0     0B     0B
    2 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      0     0B     0B
    3 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      0     0B     0B
    4 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      0     0B     0B
    5 |     -     0     0 |      0    0B |    0B    0B    0B |     0B    0B |      0     0B     0B
    6 |     -  0.00  0.00 |      0    0B |    0B    0B    0B |   310B    0B |      1   802B     0B
total |     -     -     - |      0    0B |    0B    0B    0B |   310B    0B |      3  2.5KB   502B

 kind | default  delete  elision  move  read  tomb  rewrite  copy  multi  blob
count |       1       0        0     0     0     0        0     0      0     1

COMMIT PIPELINE
               wals                |              memtables              |       ingestions
    files |    written |  overhead |   flushes |       live |     zombie |     total |   flushable
----------+------------+-----------+-----------+------------+------------+-----------+------------
   1 (0B) | 126B: 156B |     23.8% |         2 |  1 (256KB) |  1 (256KB) |       282 |      0 (0B)

ITERATORS
        block cache        |         file cache         |    filter    |  sst iters  |  snapshots
     entries |    hit rate |      entries |    hit rate |         util |        open |        open
-------------+-------------+--------------+-------------+--------------+-------------+------------
   7 (2.5KB) |       59.6% |     1 (504B) |       78.6% |         0.0% |           0 |           0

FILES                 tables                       |       blob files        |     blob values
   stats prog |    backing |                zombie |       live |     zombie |  total |      refed
--------------+------------+-----------------------+------------+------------+--------+-----------
   all loaded |     0 (0B) |       0 (0B local:0B) |   2 (245B) |     0 (0B) |    59B | 100% (59B)

CGO MEMORY    |          block cache           |                     memtables
          tot |           tot |           data |            maps |            ents |           tot
--------------+---------------+----------------+-----------------+-----------------+--------------
           0B |            0B |             0B |              0B |              0B |            0B

COMPACTIONS
   estimated debt |       in progress |         cancelled |            failed |      problem spans
------------------+-------------------+-------------------+-------------------+-------------------
               0B |            0 (0B) |            0 (0B) |                 0 |                  0

KEYS
      range keys |       tombstones |      missized tombstones |      point dels |      range dels
-----------------+------------------+--------------------------+-----------------+----------------
               0 |                0 |                        0 |              0B |              0B

COMPRESSION
    algorithm | none  snappy
on disk bytes |  61B    130B
           CR |         1.31
----
----

# Test a blob file rewrite compaction with virtual sstable references.

define value-separation=(true,1,10,0s,0.01)
----

batch
set a apple
set b banana
set c coconut
----

compact a-b
----
L6:
  000005:[a#10,SET-c#12,SET] seqnums:[10-12] points:[a#10,SET-c#12,SET] size:764 blobrefs:[(B000006: 18); depth:1]
Blob files:
  B000006 physical:{000006 size:[109 (109B)] vals:[18 (18B)]}

excise b ba
----
L6:
  000007(000005):[a#10,SET-a#10,SET] seqnums:[10-12] points:[a#10,SET-a#10,SET] size:104(764) blobrefs:[(B000006: 2); depth:1]
  000008(000005):[c#12,SET-c#12,SET] seqnums:[10-12] points:[c#12,SET-c#12,SET] size:104(764) blobrefs:[(B000006: 2); depth:1]
Blob files:
  B000006 physical:{000006 size:[109 (109B)] vals:[18 (18B)]}

# Run a blob-rewrite compaction. It'll rewrite the blob file, but it won't
# actually reclaim disk space. This is a known limitation due to the lack of
# accurate blob value liveness for virtual sstables. See
# https://github.com/cockroachdb/pebble/issues/4915.

run-blob-rewrite-compaction
----
L6:
  000007(000005):[a#10,SET-a#10,SET] seqnums:[10-12] points:[a#10,SET-a#10,SET] size:104(764) blobrefs:[(B000006: 2); depth:1]
  000008(000005):[c#12,SET-c#12,SET] seqnums:[10-12] points:[c#12,SET-c#12,SET] size:104(764) blobrefs:[(B000006: 2); depth:1]
Blob files:
  B000006 physical:{000009 size:[110 (110B)] vals:[18 (18B)]}

validate-blob-reference-index-block
000007.sst
000008.sst
----
validated

define value-separation=(true,5,5,0s,1.0) l0-compaction-threshold=1
----

# Test writing a non-trivial amount of data. With a key length of 4, we'll write
# 475254 keys each with a 64-byte value, totalling ~30MB of value data.

populate keylen=4 timestamps=(1) vallen=64
----
wrote 475254 keys

# Flush the memtable. The resulting L0 sstables should be relatively small, but
# when their sizes are summed with their corresponding blob files, the sum
# should be around the target file size of 2MB.

flush
----
L0.0:
  000005:[a@1#10,SET-bkzd@1#26000,SET] seqnums:[10-26000] points:[a@1#10,SET-bkzd@1#26000,SET] size:374304 blobrefs:[(B000006: 1663424); depth:1]
  000007:[bkze@1#26001,SET-cvxv@1#51976,SET] seqnums:[26001-51976] points:[bkze@1#26001,SET-cvxv@1#51976,SET] size:375362 blobrefs:[(B000008: 1662464); depth:1]
  000009:[cvxw@1#51977,SET-egwr@1#77958,SET] seqnums:[51977-77958] points:[cvxw@1#51977,SET-egwr@1#77958,SET] size:374995 blobrefs:[(B000010: 1662848); depth:1]
  000011:[egws@1#77959,SET-frvo@1#103940,SET] seqnums:[77959-103940] points:[egws@1#77959,SET-frvo@1#103940,SET] size:374988 blobrefs:[(B000012: 1662848); depth:1]
  000013:[frvp@1#103941,SET-hcuf@1#129917,SET] seqnums:[103941-129917] points:[frvp@1#103941,SET-hcuf@1#129917,SET] size:375240 blobrefs:[(B000014: 1662528); depth:1]
  000015:[hcug@1#129918,SET-intt@1#155916,SET] seqnums:[129918-155916] points:[hcug@1#129918,SET-intt@1#155916,SET] size:373651 blobrefs:[(B000016: 1663936); depth:1]
  000017:[intu@1#155917,SET-jyte@1#181913,SET] seqnums:[155917-181913] points:[intu@1#155917,SET-jyte@1#181913,SET] size:373856 blobrefs:[(B000018: 1663808); depth:1]
  000019:[jytf@1#181914,SET-ljsb@1#207896,SET] seqnums:[181914-207896] points:[jytf@1#181914,SET-ljsb@1#207896,SET] size:374831 blobrefs:[(B000020: 1662912); depth:1]
  000021:[ljsc@1#207897,SET-muqx@1#233876,SET] seqnums:[207897-233876] points:[ljsc@1#207897,SET-muqx@1#233876,SET] size:375093 blobrefs:[(B000022: 1662720); depth:1]
  000023:[muqy@1#233877,SET-ofox@1#259835,SET] seqnums:[233877-259835] points:[muqy@1#233877,SET-ofox@1#259835,SET] size:376560 blobrefs:[(B000024: 1661376); depth:1]
  000025:[ofoy@1#259836,SET-pqms@1#285788,SET] seqnums:[259836-285788] points:[ofoy@1#259836,SET-pqms@1#285788,SET] size:376913 blobrefs:[(B000026: 1660992); depth:1]
  000027:[pqmt@1#285789,SET-rbkv@1#311750,SET] seqnums:[285789-311750] points:[pqmt@1#285789,SET-rbkv@1#311750,SET] size:376308 blobrefs:[(B000028: 1661568); depth:1]
  000029:[rbkw@1#311751,SET-smiy@1#337711,SET] seqnums:[311751-337711] points:[rbkw@1#311751,SET-smiy@1#337711,SET] size:376373 blobrefs:[(B000030: 1661504); depth:1]
  000031:[smiz@1#337712,SET-txhz@1#363697,SET] seqnums:[337712-363697] points:[smiz@1#337712,SET-txhz@1#363697,SET] size:374708 blobrefs:[(B000032: 1663104); depth:1]
  000033:[txi@1#363698,SET-vify@1#389655,SET] seqnums:[363698-389655] points:[txi@1#363698,SET-vify@1#389655,SET] size:376543 blobrefs:[(B000034: 1661312); depth:1]
  000035:[vifz@1#389656,SET-wteb@1#415617,SET] seqnums:[389656-415617] points:[vifz@1#389656,SET-wteb@1#415617,SET] size:376291 blobrefs:[(B000036: 1661568); depth:1]
  000037:[wtec@1#415618,SET-yecg@1#441581,SET] seqnums:[415618-441581] points:[wtec@1#415618,SET-yecg@1#441581,SET] size:376099 blobrefs:[(B000038: 1661696); depth:1]
  000039:[yech@1#441582,SET-zpbv@1#467581,SET] seqnums:[441582-467581] points:[yech@1#441582,SET-zpbv@1#467581,SET] size:373668 blobrefs:[(B000040: 1664000); depth:1]
  000041:[zpbw@1#467582,SET-zzzz@1#475263,SET] seqnums:[467582-475263] points:[zpbw@1#467582,SET-zzzz@1#475263,SET] size:110075 blobrefs:[(B000042: 491648); depth:1]
Blob files:
  B000006 physical:{000006 size:[1726580 (1.6MB)] vals:[1663424 (1.6MB)]}
  B000008 physical:{000008 size:[1725564 (1.6MB)] vals:[1662464 (1.6MB)]}
  B000010 physical:{000010 size:[1725960 (1.6MB)] vals:[1662848 (1.6MB)]}
  B000012 physical:{000012 size:[1725960 (1.6MB)] vals:[1662848 (1.6MB)]}
  B000014 physical:{000014 size:[1725630 (1.6MB)] vals:[1662528 (1.6MB)]}
  B000016 physical:{000016 size:[1727108 (1.6MB)] vals:[1663936 (1.6MB)]}
  B000018 physical:{000018 size:[1726976 (1.6MB)] vals:[1663808 (1.6MB)]}
  B000020 physical:{000020 size:[1726026 (1.6MB)] vals:[1662912 (1.6MB)]}
  B000022 physical:{000022 size:[1725828 (1.6MB)] vals:[1662720 (1.6MB)]}
  B000024 physical:{000024 size:[1724442 (1.6MB)] vals:[1661376 (1.6MB)]}
  B000026 physical:{000026 size:[1724046 (1.6MB)] vals:[1660992 (1.6MB)]}
  B000028 physical:{000028 size:[1724640 (1.6MB)] vals:[1661568 (1.6MB)]}
  B000030 physical:{000030 size:[1724574 (1.6MB)] vals:[1661504 (1.6MB)]}
  B000032 physical:{000032 size:[1726224 (1.6MB)] vals:[1663104 (1.6MB)]}
  B000034 physical:{000034 size:[1724376 (1.6MB)] vals:[1661312 (1.6MB)]}
  B000036 physical:{000036 size:[1724640 (1.6MB)] vals:[1661568 (1.6MB)]}
  B000038 physical:{000038 size:[1724772 (1.6MB)] vals:[1661696 (1.6MB)]}
  B000040 physical:{000040 size:[1727174 (1.6MB)] vals:[1664000 (1.6MB)]}
  B000042 physical:{000042 size:[510360 (498KB)] vals:[491648 (480KB)]}

# Manual compaction of key range so we merge files instead of moving.
# This compaction should write data to L6. The resulting sstables will
# reference multiple blob files but maintain a blob reference depth of 1
# because L6 has no referenced blob files and all the L0
# input tables have a reference depth of 1.

compact a-zzzz
----
L6:
  000044:[a@1#0,SET-dacg@1#0,SET] seqnums:[0-0] points:[a@1#0,SET-dacg@1#0,SET] size:687925 blobrefs:[(B000006: 1663424), (B000008: 1662464), (B000010: 187776); depth:1]
  000045:[dach@1#0,SET-gafi@1#0,SET] seqnums:[0-0] points:[dach@1#0,SET-gafi@1#0,SET] size:686691 blobrefs:[(B000010: 1475072), (B000012: 1662848), (B000014: 376960); depth:1]
  000046:[gafj@1#0,SET-jahe@1#0,SET] seqnums:[0-0] points:[gafj@1#0,SET-jahe@1#0,SET] size:688628 blobrefs:[(B000014: 1285568), (B000016: 1663936), (B000018: 563264); depth:1]
  000047:[jahf@1#0,SET-majo@1#0,SET] seqnums:[0-0] points:[jahf@1#0,SET-majo@1#0,SET] size:687171 blobrefs:[(B000018: 1100544), (B000020: 1662912), (B000022: 750208); depth:1]
  000048:[majp@1#0,SET-palp@1#0,SET] seqnums:[0-0] points:[majp@1#0,SET-palp@1#0,SET] size:688015 blobrefs:[(B000022: 912512), (B000024: 1661376), (B000026: 939200); depth:1]
  000049:[palq@1#0,SET-sanm@1#0,SET] seqnums:[0-0] points:[palq@1#0,SET-sanm@1#0,SET] size:688168 blobrefs:[(B000026: 721792), (B000028: 1661568), (B000030: 1129472); depth:1]
  000050:[sann@1#0,SET-vapo@1#0,SET] seqnums:[0-0] points:[sann@1#0,SET-vapo@1#0,SET] size:687798 blobrefs:[(B000030: 532032), (B000032: 1663104), (B000034: 1318016); depth:1]
  000051:[vapp@1#0,SET-yaru@1#0,SET] seqnums:[0-0] points:[vapp@1#0,SET-yaru@1#0,SET] size:687664 blobrefs:[(B000034: 343296), (B000036: 1661568), (B000038: 1508544); depth:1]
  000052:[yarv@1#0,SET-zzzz@1#0,SET] seqnums:[0-0] points:[yarv@1#0,SET-zzzz@1#0,SET] size:449649 blobrefs:[(B000038: 153152), (B000040: 1664000), (B000042: 491648); depth:1]
Blob files:
  B000006 physical:{000006 size:[1726580 (1.6MB)] vals:[1663424 (1.6MB)]}
  B000008 physical:{000008 size:[1725564 (1.6MB)] vals:[1662464 (1.6MB)]}
  B000010 physical:{000010 size:[1725960 (1.6MB)] vals:[1662848 (1.6MB)]}
  B000012 physical:{000012 size:[1725960 (1.6MB)] vals:[1662848 (1.6MB)]}
  B000014 physical:{000014 size:[1725630 (1.6MB)] vals:[1662528 (1.6MB)]}
  B000016 physical:{000016 size:[1727108 (1.6MB)] vals:[1663936 (1.6MB)]}
  B000018 physical:{000018 size:[1726976 (1.6MB)] vals:[1663808 (1.6MB)]}
  B000020 physical:{000020 size:[1726026 (1.6MB)] vals:[1662912 (1.6MB)]}
  B000022 physical:{000022 size:[1725828 (1.6MB)] vals:[1662720 (1.6MB)]}
  B000024 physical:{000024 size:[1724442 (1.6MB)] vals:[1661376 (1.6MB)]}
  B000026 physical:{000026 size:[1724046 (1.6MB)] vals:[1660992 (1.6MB)]}
  B000028 physical:{000028 size:[1724640 (1.6MB)] vals:[1661568 (1.6MB)]}
  B000030 physical:{000030 size:[1724574 (1.6MB)] vals:[1661504 (1.6MB)]}
  B000032 physical:{000032 size:[1726224 (1.6MB)] vals:[1663104 (1.6MB)]}
  B000034 physical:{000034 size:[1724376 (1.6MB)] vals:[1661312 (1.6MB)]}
  B000036 physical:{000036 size:[1724640 (1.6MB)] vals:[1661568 (1.6MB)]}
  B000038 physical:{000038 size:[1724772 (1.6MB)] vals:[1661696 (1.6MB)]}
  B000040 physical:{000040 size:[1727174 (1.6MB)] vals:[1664000 (1.6MB)]}
  B000042 physical:{000042 size:[510360 (498KB)] vals:[491648 (480KB)]}


excise-dryrun b c
----
would excise 1 files.
  del-table:     L6 000044
  add-table:     L6 000053(000044):[a@1#0,SET-azzz@1#0,SET] seqnums:[0-0] points:[a@1#0,SET-azzz@1#0,SET] size:226712(687925) blobrefs:[(B000006: 548196), (B000008: 547880), (B000010: 61883); depth:1]
  add-table:     L6 000054(000044):[c@1#0,SET-dacg@1#0,SET] seqnums:[0-0] points:[c@1#0,SET-dacg@1#0,SET] size:229689(687925) blobrefs:[(B000006: 555395), (B000008: 555074), (B000010: 62695); depth:1]
  add-backing:   000044


# Test a value separation policy that is configured to only separate values ≥
# 1024 bytes, but there's also a key span defined with the latency-tolerant
# value storage policy.

define value-separation=(true,1024,10,0s,1.0) latency-tolerant-span=(f,o)
----

batch
set a hello
set b helloworld
set c helloworld!
set d hello
set e helloworld
set f helloworld!
set g hello
set h helloworld
set i helloworld!
set j hello
set k helloworld
set l helloworld!
set m hello
set n helloworld
set o helloworld!
set p hello
set q helloworld
set r helloworld!
set s hello
set t helloworld
set u helloworld!
set v hello
set w helloworld
set x helloworld!
set y hello
set z helloworld
----

flush
----
L0.0:
  000005:[a#10,SET-e#14,SET] seqnums:[10-14] points:[a#10,SET-e#14,SET] size:709
  000006:[f#15,SET-n#23,SET] seqnums:[15-23] points:[f#15,SET-n#23,SET] size:827 blobrefs:[(B000007: 63); depth:1]
  000008:[o#24,SET-z#35,SET] seqnums:[24-35] points:[o#24,SET-z#35,SET] size:746
Blob files:
  B000007 physical:{000007 size:[115 (115B)] vals:[63 (63B)]}

iter
first
next
next
stats
next
next
next
stats
next
next
next
stats
next
next
next
stats
next
next
next
stats
next
next
next
stats
next
next
next
stats
next
next
next
stats
----
a: (hello, .)
b: (helloworld, .)
c: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 2 times (2 internal); blocks: 158B cached; points: 3 (3B keys, 26B values)
d: (hello, .)
e: (helloworld, .)
f: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 5 times (5 internal); blocks: 421B cached; points: 6 (6B keys, 43B values); separated: 1 (11B, 11B fetched)
g: (hello, .)
h: (helloworld, .)
i: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 8 times (8 internal); blocks: 421B cached; points: 9 (9B keys, 52B values); separated: 3 (32B, 32B fetched)
j: (hello, .)
k: (helloworld, .)
l: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 11 times (11 internal); blocks: 421B cached; points: 12 (12B keys, 61B values); separated: 5 (53B, 53B fetched)
m: (hello, .)
n: (helloworld, .)
o: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 14 times (14 internal); blocks: 615B cached; points: 15 (15B keys, 79B values); separated: 6 (63B, 63B fetched)
p: (hello, .)
q: (helloworld, .)
r: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 17 times (17 internal); blocks: 615B cached; points: 18 (18B keys, 105B values); separated: 6 (63B, 63B fetched)
s: (hello, .)
t: (helloworld, .)
u: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 20 times (20 internal); blocks: 615B cached; points: 21 (21B keys, 131B values); separated: 6 (63B, 63B fetched)
v: (hello, .)
w: (helloworld, .)
x: (helloworld!, .)
stats: seeked 1 times (1 internal); stepped 23 times (23 internal); blocks: 615B cached; points: 24 (24B keys, 157B values); separated: 6 (63B, 63B fetched)
