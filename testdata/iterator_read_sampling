# Test with overlapping keys across levels, should pick top level to compact after allowed-seeks goes to 0
# Verify that Iterator.First(), Iterator.SeekGE() and Iterator.Next() call maybe sample read.
define auto-compactions=off
L0
  a.SET.4:4
L1
  a.SET.3:3
L2
  d.SET.2:2
L3
  d.SET.1:1
----
0.0:
  000004:[a#4,SET-a#4,SET]
1:
  000005:[a#3,SET-a#3,SET]
2:
  000006:[d#2,SET-d#2,SET]
3:
  000007:[d#1,SET-d#1,SET]

set allowed-seeks=2
----


iter
first
----
a:4

iter-read-compactions
----
(none)

iter
first
----
a:4

iter-read-compactions
----
(level: 0, start: a, end: a)

read-compactions
----
(none)

close-iter
----

read-compactions
----
(level: 0, start: a, end: a)

iter
seek-ge d
----
d:2

iter
prev
----
a:4

iter
next
----
d:2

iter-read-compactions
----
(level: 2, start: d, end: d)

close-iter
----

read-compactions
----
(level: 0, start: a, end: a)
(level: 2, start: d, end: d)



# Verify that Iterator.Last(), Iterator.SeekLT() and Iterator.Prev() call maybe sample read.
define auto-compactions=off
L0
  a.SET.4:4
  c.SET.8:8
L1
  a.SET.3:3
  c.SET.9:9
L2
  d.SET.2:2
  l.SET.7:7
L3
  d.SET.1:1
  l.SET.8:8
----
0.0:
  000004:[a#4,SET-c#8,SET]
1:
  000005:[a#3,SET-c#9,SET]
2:
  000006:[d#2,SET-l#7,SET]
3:
  000007:[d#1,SET-l#8,SET]

set allowed-seeks=2
----


iter
last
----
l:8

iter-read-compactions
----
(none)

iter
last
----
l:8

iter-read-compactions
----
(level: 2, start: d, end: l)

read-compactions
----
(none)

close-iter
----

read-compactions
----
(level: 2, start: d, end: l)

iter
seek-lt d
----
c:9

iter
next
----
d:2

iter
prev
----
c:9

iter-read-compactions
----
(level: 0, start: a, end: c)

close-iter
----

read-compactions
----
(level: 2, start: d, end: l)
(level: 0, start: a, end: c)


# Edge case: For Iterator.Last(), Iterator.SeekLT() and Iterator.Prev(), if the key is the first key of the file or
# the only key, the iterator moves past the file. Sampling should be able to handle this and seek to the correct file.
# This test checks for both cases of iterator position: invalid iterator (key=a) and prev file (key=d)
define auto-compactions=off
L0
  a.SET.4:4
L1
  a.SET.3:3
L2
  d.SET.2:2
L2
  c.SET.1:1
L3
  d.SET.1:1
----
0.0:
  000004:[a#4,SET-a#4,SET]
1:
  000005:[a#3,SET-a#3,SET]
2:
  000007:[c#1,SET-c#1,SET]
  000006:[d#2,SET-d#2,SET]
3:
  000008:[d#1,SET-d#1,SET]

set allowed-seeks=2
----


iter
last
----
d:2

iter-read-compactions
----
(none)

iter
last
----
d:2

iter-read-compactions
----
(level: 2, start: d, end: d)

read-compactions
----
(none)

close-iter
----

read-compactions
----
(level: 2, start: d, end: d)

iter
seek-lt c
----
a:4

iter
next
----
c:1

iter
prev
----
a:4

iter-read-compactions
----
(level: 0, start: a, end: a)

close-iter
----

read-compactions
----
(level: 2, start: d, end: d)
(level: 0, start: a, end: a)

# Same edge case as above, except for the sampled key coming from L0 sublevels.
define auto-compactions=off
L0
  e.SET.4:4
L0
  e.SET.5:5
L0
  e.SET.6:6
L0
  e.SET.7:7
  f.DEL.7:
L1
  e.SET.3:3
L2
  d.SET.2:2
L2
  c.SET.1:1
L3
  d.SET.1:1
----
0.3:
  000007:[e#7,SET-f#7,DEL]
0.2:
  000006:[e#6,SET-e#6,SET]
0.1:
  000005:[e#5,SET-e#5,SET]
0.0:
  000004:[e#4,SET-e#4,SET]
1:
  000008:[e#3,SET-e#3,SET]
2:
  000010:[c#1,SET-c#1,SET]
  000009:[d#2,SET-d#2,SET]
3:
  000011:[d#1,SET-d#1,SET]

set allowed-seeks=2
----


iter
last
----
e:7

iter-read-compactions
----
(none)

iter
last
----
e:7

iter-read-compactions
----
(level: 0, start: e, end: f)

read-compactions
----
(none)

close-iter
----

read-compactions
----
(level: 0, start: e, end: f)

iter
seek-lt e
----
d:2

iter
next
----
e:7

iter
prev
----
d:2

iter-read-compactions
----
(level: 2, start: d, end: d)

close-iter
----

read-compactions
----
(level: 0, start: e, end: f)
(level: 2, start: d, end: d)


# Edge case (for `MERGE` keys): For Iterator.First(), Iterator.SeekGE() and Iterator.Next(), if the key is the last key
# of the file or the only key, the iterator moves past the file. Sampling should be able to handle this and seek to the
# correct file.
define auto-compactions=off
L0
  a.MERGE.4:4
L1
  a.MERGE.3:3
  b.MERGE.6:6
L2
  d.MERGE.2:2
L2
  c.MERGE.1:1
L3
  c.MERGE.1:1
----
0.0:
  000004:[a#4,MERGE-a#4,MERGE]
1:
  000005:[a#3,MERGE-b#6,MERGE]
2:
  000007:[c#1,MERGE-c#1,MERGE]
  000006:[d#2,MERGE-d#2,MERGE]
3:
  000008:[c#1,MERGE-c#1,MERGE]

set allowed-seeks=2
----


iter
first
----
a:34

iter-read-compactions
----
(none)

iter
first
----
a:34

iter-read-compactions
----
(level: 0, start: a, end: a)

read-compactions
----
(none)

close-iter
----

read-compactions
----
(level: 0, start: a, end: a)

iter
seek-ge c
----
c:11

iter
prev
----
b:6

iter
next
----
c:11

iter-read-compactions
----
(level: 2, start: c, end: c)

close-iter
----

read-compactions
----
(level: 0, start: a, end: a)
(level: 2, start: c, end: c)


# Test with no overlapping keys across levels, should not pick any compaction
define auto-compactions=off
L0
  a.SET.4:4
L1
  b.SET.3:3
L2
  c.SET.2:2
L3
  d.SET.1:1
----
0.0:
  000004:[a#4,SET-a#4,SET]
1:
  000005:[b#3,SET-b#3,SET]
2:
  000006:[c#2,SET-c#2,SET]
3:
  000007:[d#1,SET-d#1,SET]

set allowed-seeks=3
----

iter
first
----
a:4

iter
first
----
a:4

iter
first
----
a:4

iter-read-compactions
----
(none)

close-iter
----

read-compactions
----
(none)
