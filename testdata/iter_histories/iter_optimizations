# Test repeated seeks into the same range key, while TrySeekUsingNext=true.
# Test for regression fixed in #1849.

reset
----

batch commit
range-key-set a c @5 boop
range-key-set c e @5 beep
----
committed 2 keys

combined-iter
seek-ge a
seek-ge b
----
a: (., [a-c) @5=boop UPDATED)
b: (., [a-c) @5=boop)

# Ensure that no-op optimizations do not reuse range key iterator state across
# SetOptions calls. No-op optimizations have the potential to fail to update
# RangeKeyChanged().

reset
----

batch commit
range-key-set p s @1 foo
----
committed 1 keys

combined-iter lower=n@9 upper=x@5
seek-lt y@3
set-options lower=n@9 upper=x@5
seek-lt-limit t o
----
p: (., [p-s) @1=foo UPDATED)
.
p: valid (., [p-s) @1=foo UPDATED)

combined-iter lower=n@9 upper=x@5
seek-ge o
set-options lower=n@9 upper=x@5
seek-ge oat
----
p: (., [p-s) @1=foo UPDATED)
.
p: (., [p-s) @1=foo UPDATED)

combined-iter lower=n@9 upper=x@5
seek-prefix-ge p@5
set-options lower=n@9 upper=x@5
seek-prefix-ge p
----
p@5: (., [p-"p\x00") @1=foo UPDATED)
.
p: (., [p-"p\x00") @1=foo UPDATED)

# Regression test for #1963 / cockroachdb/cockroach#88296.
#
# The iterators in this test move their bounds monotonically forward
# [a,b)â†’[b,e). This enables the sstable iterator optimization for monotonically
# moving bounds (see boundsCmp in sstable/reader.go). With this optimization,
# the first seek after the SetBounds may use the fact that the bounds moved
# forward monotonically to avoid re-seeking within the index.
#
# The test cases below exercise a seek to a key, followed by a seek to a smaller
# key. The second seek should not make use of the bounds optimization because
# doing so may incorrectly skip all keys between the lower bound and the first
# seek key. Previously, the code paths that handled block-property filtering on
# a two-level iterator could leave the iterator in a state such that the second
# seek would improperly also exercise the monotonic bounds optimization. In the
# test cases below, this would result in the key 'b' not being found. Each test
# case exercises a different combination of seek-ge and seek-prefix-ge.

reset block-size=1 index-block-size=1
----

batch commit
set a a
set b b
set b@4 b@4
set z@6 z@6
----
committed 4 keys

flush
----

combined-iter lower=a upper=b point-key-filter=(1,4)
seek-ge a
set-bounds lower=b upper=e
seek-prefix-ge d@5
seek-prefix-ge b
----
a: (a, .)
.
.
b: (b, .)

combined-iter lower=a upper=b point-key-filter=(1,4)
seek-ge a
set-bounds lower=b upper=e
seek-ge d@5
seek-prefix-ge b
----
a: (a, .)
.
.
b: (b, .)

combined-iter lower=a upper=b point-key-filter=(1,4)
seek-ge a
set-bounds lower=b upper=e
seek-ge d@5
seek-ge b
----
a: (a, .)
.
.
b: (b, .)

combined-iter lower=a upper=b point-key-filter=(1,4)
seek-ge a
set-bounds lower=b upper=e
seek-prefix-ge d@5
seek-ge b
----
a: (a, .)
.
.
b: (b, .)

# Test a similar case with range key masking. The previous bug did not apply to
# this case, because range-key masking never skips blocks on a seek.

reset block-size=1 index-block-size=1
----

batch commit
set a a
set b b
set b@4 b@4
set z@6 z@6
range-key-set a z @9 v
----
committed 5 keys

flush
----

combined-iter lower=a upper=b mask-suffix=@10 mask-filter
seek-ge a
set-bounds lower=b upper=e
seek-prefix-ge d@5
seek-ge b
----
a: (a, [a-b) @9=v UPDATED)
.
d@5: (., [d-"d\x00") @9=v UPDATED)
b: (b, [b-e) @9=v UPDATED)
