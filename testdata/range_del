# 1 memtable.

define
mem
  a#10,SET:b
  a#12,SET:c
  a#14,SET:d
  b#10,MERGE:b
  b#12,MERGE:c
  b#14,MERGE:d
  b#15,RANGEDEL:c
  b#16,MERGE:e
  c#10,SET:b
  c#12,SET:c
  c#14,SET:d
----
mem: 1

get seq=11
a
b
c
----
a:b
b:b
c:b

get seq=13
a
b
c
----
a:c
b:bc
c:c

get seq=15
a
b
c
----
a:d
b:bcd
c:d

get seq=16
a
b
c
----
a:d
b: pebble: not found
c:d

get seq=17
a
b
c
----
a:d
b:e
c:d

get seq=15
a
b
c
----
a:d
b:bcd
c:d

iter seq=15
first
next
next
next
seek-ge a
seek-ge b
seek-ge c
seek-ge d
last
prev
prev
prev
seek-lt a
seek-lt b
seek-lt c
seek-lt d
----
a: (d, .)
b: (bcd, .)
c: (d, .)
.
a: (d, .)
b: (bcd, .)
c: (d, .)
.
c: (d, .)
b: (bcd, .)
a: (d, .)
.
.
a: (d, .)
b: (bcd, .)
c: (d, .)

iter seq=16
first
next
next
seek-ge a
seek-ge b
seek-ge c
seek-ge d
last
prev
prev
seek-lt a
seek-lt b
seek-lt c
seek-lt d
----
a: (d, .)
c: (d, .)
.
a: (d, .)
c: (d, .)
c: (d, .)
.
c: (d, .)
a: (d, .)
.
.
a: (d, .)
a: (d, .)
c: (d, .)

# Multiple memtables.

define
mem
  a#10,SET:b
  b#10,MERGE:b
  c#10,SET:b
mem
  a#12,SET:c
  b#12,MERGE:c
  c#12,SET:c
mem
  a#14,SET:d
  b#14,MERGE:d
  c#14,SET:d
mem
  b#15,RANGEDEL:c
mem
  b#16,MERGE:e
----
mem: 5

get seq=11
a
b
c
----
a:b
b:b
c:b

get seq=13
a
b
c
----
a:c
b:bc
c:c

get seq=15
a
b
c
----
a:d
b:bcd
c:d

get seq=16
a
b
c
----
a:d
b: pebble: not found
c:d

get seq=17
a
b
c
----
a:d
b:e
c:d

get seq=15
a
b
c
----
a:d
b:bcd
c:d

iter seq=15
first
next
next
next
seek-ge a
seek-ge b
seek-ge c
seek-ge d
last
prev
prev
prev
seek-lt a
seek-lt b
seek-lt c
seek-lt d
----
a: (d, .)
b: (bcd, .)
c: (d, .)
.
a: (d, .)
b: (bcd, .)
c: (d, .)
.
c: (d, .)
b: (bcd, .)
a: (d, .)
.
.
a: (d, .)
b: (bcd, .)
c: (d, .)

iter seq=16
first
next
next
seek-ge a
seek-ge b
seek-ge c
seek-ge d
last
prev
prev
seek-lt a
seek-lt b
seek-lt c
seek-lt d
----
a: (d, .)
c: (d, .)
.
a: (d, .)
c: (d, .)
c: (d, .)
.
c: (d, .)
a: (d, .)
.
.
a: (d, .)
a: (d, .)
c: (d, .)

# Overlapping range deletions in the same memtable.

define
mem
  a#10,SET:1
  a#12,SET:2
  a#14,SET:3
  a#16,SET:4
  b#10,SET:1
  b#12,SET:2
  b#14,SET:3
  b#16,SET:4
  c#10,SET:1
  c#12,SET:2
  c#14,SET:3
  c#16,SET:4
  d#10,SET:1
  d#12,SET:2
  d#14,SET:3
  d#16,SET:4
  a#11,RANGEDEL:b
  b#13,RANGEDEL:c
  b#11,RANGEDEL:c
  c#15,RANGEDEL:d
  c#13,RANGEDEL:d
  c#11,RANGEDEL:d
----
mem: 1

get seq=11
a
b
c
d
----
a:1
b:1
c:1
d:1

get seq=12
a
b
c
d
----
a: pebble: not found
b: pebble: not found
c: pebble: not found
d:1

get seq=14
a
b
c
d
----
a:2
b: pebble: not found
c: pebble: not found
d:2

get seq=16
a
b
c
d
----
a:3
b:3
c: pebble: not found
d:3

get seq=18
a
b
c
d
----
a:4
b:4
c:4
d:4

iter seq=11
first
next
next
next
next
last
prev
prev
prev
prev
----
a: (1, .)
b: (1, .)
c: (1, .)
d: (1, .)
.
d: (1, .)
c: (1, .)
b: (1, .)
a: (1, .)
.

iter seq=12
first
next
last
prev
----
d: (1, .)
.
d: (1, .)
.

iter seq=14
first
next
next
last
prev
prev
----
a: (2, .)
d: (2, .)
.
d: (2, .)
a: (2, .)
.

iter seq=16
first
next
next
next
last
prev
prev
prev
----
a: (3, .)
b: (3, .)
d: (3, .)
.
d: (3, .)
b: (3, .)
a: (3, .)
.

iter seq=18
first
next
next
next
next
last
prev
prev
prev
prev
----
a: (4, .)
b: (4, .)
c: (4, .)
d: (4, .)
.
d: (4, .)
c: (4, .)
b: (4, .)
a: (4, .)
.

# Overlapping range deletions in different memtables. Note that the
# range tombstones are not fragmented in this case.

define
mem
  a#10,SET:1
  b#10,SET:1
  c#10,SET:1
  d#10,SET:1
mem
  a#12,SET:2
  b#12,SET:2
  c#12,SET:2
  d#12,SET:2
  a#11,RANGEDEL:d
mem
  a#14,SET:3
  b#14,SET:3
  c#14,SET:3
  d#14,SET:3
  b#13,RANGEDEL:d
mem
  a#16,SET:4
  b#16,SET:4
  c#16,SET:4
  d#16,SET:4
  c#13,RANGEDEL:d
----
mem: 4

get seq=11
a
b
c
d
----
a:1
b:1
c:1
d:1

get seq=12
a
b
c
d
----
a: pebble: not found
b: pebble: not found
c: pebble: not found
d:1

get seq=14
a
b
c
d
----
a:2
b: pebble: not found
c: pebble: not found
d:2

get seq=16
a
b
c
d
----
a:3
b:3
c: pebble: not found
d:3

get seq=18
a
b
c
d
----
a:4
b:4
c:4
d:4

iter seq=11
first
next
next
next
next
last
prev
prev
prev
prev
----
a: (1, .)
b: (1, .)
c: (1, .)
d: (1, .)
.
d: (1, .)
c: (1, .)
b: (1, .)
a: (1, .)
.

iter seq=12
first
next
last
prev
----
d: (1, .)
.
d: (1, .)
.

iter seq=14
first
next
next
last
prev
prev
----
a: (2, .)
d: (2, .)
.
d: (2, .)
a: (2, .)
.

iter seq=16
first
next
next
next
last
prev
prev
prev
----
a: (3, .)
b: (3, .)
d: (3, .)
.
d: (3, .)
b: (3, .)
a: (3, .)
.

iter seq=18
first
next
next
next
next
last
prev
prev
prev
prev
----
a: (4, .)
b: (4, .)
c: (4, .)
d: (4, .)
.
d: (4, .)
c: (4, .)
b: (4, .)
a: (4, .)
.

# User-key spread across multiple levels.

define
mem
  a#13,MERGE:4
L1
  a#12,MERGE:3
L2
  a#11,MERGE:2
L3
  a#10,MERGE:1
----
mem: 1
L1:
  000004:[a#12,MERGE-a#12,MERGE]
L2:
  000005:[a#11,MERGE-a#11,MERGE]
L3:
  000006:[a#10,MERGE-a#10,MERGE]

get seq=10
a
----
a: pebble: not found

get seq=11
a
----
a:1

get seq=12
a
----
a:12

get seq=13
a
----
a:123

get seq=14
a
----
a:1234

iter seq=11
first
seek-ge a
seek-ge b
last
seek-lt a
seek-lt b
----
a: (1, .)
a: (1, .)
.
a: (1, .)
.
a: (1, .)

iter seq=12
first
seek-ge a
seek-ge b
last
seek-lt a
seek-lt b
----
a: (12, .)
a: (12, .)
.
a: (12, .)
.
a: (12, .)

iter seq=13
first
seek-ge a
seek-ge b
last
seek-lt a
seek-lt b
----
a: (123, .)
a: (123, .)
.
a: (123, .)
.
a: (123, .)

iter seq=14
first
seek-ge a
seek-ge b
last
seek-lt a
seek-lt b
----
a: (1234, .)
a: (1234, .)
.
a: (1234, .)
.
a: (1234, .)

# Range deletions on multiple levels.
define
L0
  a#13,SET:4
  b#13,SET:4
  d#13,SET:4
  c#13,RANGEDEL:d
L1
  a#12,SET:3
  d#12,SET:3
  b#12,RANGEDEL:d
L2
  d#11,SET:2
  a#11,RANGEDEL:d
L3
  a#10,SET:1
  b#10,SET:1
  c#10,SET:1
  d#10,SET:1
----
mem: 1
L0.0:
  000004:[a#13,SET-d#13,SET]
L1:
  000005:[a#12,SET-d#12,SET]
L2:
  000006:[a#11,RANGEDEL-d#11,SET]
L3:
  000007:[a#10,SET-d#10,SET]

get seq=11
a
b
c
d
----
a:1
b:1
c:1
d:1

get seq=12
a
b
c
d
----
a: pebble: not found
b: pebble: not found
c: pebble: not found
d:2

get seq=13
a
b
c
d
----
a:3
b: pebble: not found
c: pebble: not found
d:3

get seq=14
a
b
c
d
----
a:4
b:4
c: pebble: not found
d:4

iter seq=11
first
next
next
next
last
prev
prev
prev
----
a: (1, .)
b: (1, .)
c: (1, .)
d: (1, .)
d: (1, .)
c: (1, .)
b: (1, .)
a: (1, .)

iter seq=12
first
last
----
d: (2, .)
d: (2, .)

iter seq=13
first
next
last
prev
----
a: (3, .)
d: (3, .)
d: (3, .)
a: (3, .)

iter seq=14
first
next
next
last
prev
prev
----
a: (4, .)
b: (4, .)
d: (4, .)
d: (4, .)
b: (4, .)
a: (4, .)

# Range deletions spanning tables within a level.

define
mem
  a#12,SET:3
  b#12,SET:3
  c#12,SET:3
  d#12,SET:3
L1
  a#11,RANGEDEL:b
L1
  b#11,RANGEDEL:c
L1
  c#11,RANGEDEL:d
L2
  a#10,SET:1
  b#10,SET:1
  c#10,SET:1
  d#10,SET:1
----
mem: 1
L1:
  000004:[a#11,RANGEDEL-b#inf,RANGEDEL]
  000005:[b#11,RANGEDEL-c#inf,RANGEDEL]
  000006:[c#11,RANGEDEL-d#inf,RANGEDEL]
L2:
  000007:[a#10,SET-d#10,SET]

get seq=11
a
b
c
d
----
a:1
b:1
c:1
d:1

get seq=12
a
b
c
d
----
a: pebble: not found
b: pebble: not found
c: pebble: not found
d:1

get seq=13
a
b
c
d
----
a:3
b:3
c:3
d:3

iter seq=11
first
next
next
next
last
prev
prev
prev
----
a: (1, .)
b: (1, .)
c: (1, .)
d: (1, .)
d: (1, .)
c: (1, .)
b: (1, .)
a: (1, .)

iter seq=12
first
last
----
d: (1, .)
d: (1, .)

iter seq=13
first
next
next
next
last
prev
prev
prev
----
a: (3, .)
b: (3, .)
c: (3, .)
d: (3, .)
d: (3, .)
c: (3, .)
b: (3, .)
a: (3, .)

# Invalid LSM structure (range deletion at newer level covers newer
# write at an older level). This LSM structure is not generated
# naturally, but tested here to show the level-by-level nature of Get.

define
L1
  a#10,RANGEDEL:b
L2
  a#11,SET:2
----
mem: 1
L1:
  000004:[a#10,RANGEDEL-b#inf,RANGEDEL]
L2:
  000005:[a#11,SET-a#11,SET]

get seq=12
a
----
a: pebble: not found

# A range tombstone straddles two SSTs. One is compacted to a lower level. Its
# keys that are newer than the range tombstone should not disappear.
#
# Uses a snapshot to prevent range tombstone from being elided when it gets
# compacted to the bottommost level.

define target-file-sizes=(100, 1) snapshots=(1)
L0
  a#10,RANGEDEL:e
L0
  a#11,SET:v
L0
  c#12,SET:v
----
mem: 1
L0.1:
  000005:[a#11,SET-a#11,SET]
  000006:[c#12,SET-c#12,SET]
L0.0:
  000004:[a#10,RANGEDEL-e#inf,RANGEDEL]

compact a-e
----
L1:
  000007:[a#11,SET-c#inf,RANGEDEL]
  000008:[c#12,SET-e#inf,RANGEDEL]

compact d-e
----
L1:
  000007:[a#11,SET-c#inf,RANGEDEL]
L2:
  000008:[c#12,SET-e#inf,RANGEDEL]

iter seq=13
seek-ge b
next
----
c: (v, .)
.

# Reverse the above test: compact the left file containing the split range
# tombstone downwards, and iterate from right to left.

define target-file-sizes=(100, 1) snapshots=(1)
L0
  a#10,RANGEDEL:e
L0
  a#11,SET:v
L0
  c#12,SET:v
----
mem: 1
L0.1:
  000005:[a#11,SET-a#11,SET]
  000006:[c#12,SET-c#12,SET]
L0.0:
  000004:[a#10,RANGEDEL-e#inf,RANGEDEL]

compact a-e
----
L1:
  000007:[a#11,SET-c#inf,RANGEDEL]
  000008:[c#12,SET-e#inf,RANGEDEL]

compact a-b
----
L1:
  000008:[c#12,SET-e#inf,RANGEDEL]
L2:
  000007:[a#11,SET-c#inf,RANGEDEL]

iter seq=13
seek-lt d
prev
prev
----
c: (v, .)
a: (v, .)
.

# A range tombstone straddles two sstables. One is compacted two
# levels lower. The other is compacted one level lower. The one that
# is compacted one level lower should not see its boundaries expand
# causing it to delete more keys. A snapshot is used to prevent range
# tombstone from being elided when it gets compacted to the bottommost
# level.

define target-file-sizes=(100, 1) snapshots=(1)
L0
  a#10,RANGEDEL:e
L0
  a#11,SET:v
L0
  c#12,SET:v
L2
  d#0,SET:v
----
mem: 1
L0.1:
  000005:[a#11,SET-a#11,SET]
  000006:[c#12,SET-c#12,SET]
L0.0:
  000004:[a#10,RANGEDEL-e#inf,RANGEDEL]
L2:
  000007:[d#0,SET-d#0,SET]

compact a-b
----
L1:
  000008:[a#11,SET-c#inf,RANGEDEL]
  000009:[c#12,SET-d#inf,RANGEDEL]
  000010:[d#10,RANGEDEL-e#inf,RANGEDEL]
L2:
  000007:[d#0,SET-d#0,SET]

compact d-e
----
L1:
  000008:[a#11,SET-c#inf,RANGEDEL]
  000009:[c#12,SET-d#inf,RANGEDEL]
L3:
  000011:[d#10,RANGEDEL-e#inf,RANGEDEL]

get seq=13
c
----
c:v

compact a-b L1
----
L1:
  000009:[c#12,SET-d#inf,RANGEDEL]
L2:
  000008:[a#11,SET-c#inf,RANGEDEL]
L3:
  000011:[d#10,RANGEDEL-e#inf,RANGEDEL]

get seq=13
c
----
c:v

# A slight variation on the scenario above where a range tombstone is
# expanded past the boundaries of its "atomic compaction unit".

define target-file-sizes=(100, 1) snapshots=(1)
L0
  a#10,RANGEDEL:e
L0
  a#11,SET:v
L0
  c#12,SET:v
L0
  f#13,SET:v
L2
  d#0,SET:v
----
mem: 1
L0.1:
  000005:[a#11,SET-a#11,SET]
  000006:[c#12,SET-c#12,SET]
L0.0:
  000004:[a#10,RANGEDEL-e#inf,RANGEDEL]
  000007:[f#13,SET-f#13,SET]
L2:
  000008:[d#0,SET-d#0,SET]

compact a-b
----
L0.0:
  000007:[f#13,SET-f#13,SET]
L1:
  000009:[a#11,SET-c#inf,RANGEDEL]
  000010:[c#12,SET-d#inf,RANGEDEL]
  000011:[d#10,RANGEDEL-e#inf,RANGEDEL]
L2:
  000008:[d#0,SET-d#0,SET]

compact d-e
----
L0.0:
  000007:[f#13,SET-f#13,SET]
L1:
  000009:[a#11,SET-c#inf,RANGEDEL]
  000010:[c#12,SET-d#inf,RANGEDEL]
L3:
  000012:[d#10,RANGEDEL-e#inf,RANGEDEL]

get seq=13
c
----
c:v

compact f-f L0
----
L1:
  000009:[a#11,SET-c#inf,RANGEDEL]
  000010:[c#12,SET-d#inf,RANGEDEL]
  000007:[f#13,SET-f#13,SET]
L3:
  000012:[d#10,RANGEDEL-e#inf,RANGEDEL]

compact a-f L1
----
L2:
  000013:[a#11,SET-c#inf,RANGEDEL]
  000014:[c#12,SET-d#inf,RANGEDEL]
  000015:[f#13,SET-f#13,SET]
L3:
  000012:[d#10,RANGEDEL-e#inf,RANGEDEL]

get seq=13
c
----
c:v

define
L0
  a#12,RANGEDEL:f
L0
  a#13,RANGEDEL:c
  c#13,RANGEDEL:f
L1
  b#11,RANGEDEL:e
L2
  c#10,RANGEDEL:d
----
mem: 1
L0.1:
  000005:[a#13,RANGEDEL-f#inf,RANGEDEL]
L0.0:
  000004:[a#12,RANGEDEL-f#inf,RANGEDEL]
L1:
  000006:[b#11,RANGEDEL-e#inf,RANGEDEL]
L2:
  000007:[c#10,RANGEDEL-d#inf,RANGEDEL]

wait-pending-table-stats
000007
----
num-entries: 1
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 0

wait-pending-table-stats
000006
----
num-entries: 1
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 495

wait-pending-table-stats
000004
----
num-entries: 1
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 990

wait-pending-table-stats
000005
----
num-entries: 2
num-deletions: 2
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 990


# Range deletions with varying overlap.
define
L0
  a#13,SET:4
  b#13,SET:4
  d#13,SET:4
  c#13,RANGEDEL:d
L1
  a#12,SET:3
  d#12,SET:3
  b#12,RANGEDEL:d
L2
  d#11,SET:2
  a#11,RANGEDEL:d
L3
  a#10,SET:1
  b#10,SET:1
  c#10,SET:1
  d#10,SET:1
----
mem: 1
L0.0:
  000004:[a#13,SET-d#13,SET]
L1:
  000005:[a#12,SET-d#12,SET]
L2:
  000006:[a#11,RANGEDEL-d#11,SET]
L3:
  000007:[a#10,SET-d#10,SET]

wait-pending-table-stats
000007
----
num-entries: 4
num-deletions: 0
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 0

wait-pending-table-stats
000006
----
num-entries: 2
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 42

wait-pending-table-stats
000005
----
num-entries: 3
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 68

wait-pending-table-stats
000004
----
num-entries: 4
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 100

# Multiple Range deletions in a table.
define
L0
  a#15,RANGEDEL:d
  e#15,RANGEDEL:z
L0
  a#14,RANGEDEL:d
L0
  e#13,RANGEDEL:z
L1
  a#11,SET:1
  b#11,SET:1
  c#11,SET:1
L2
  x#10,SET:2
----
mem: 1
L0.1:
  000004:[a#15,RANGEDEL-z#inf,RANGEDEL]
L0.0:
  000005:[a#14,RANGEDEL-d#inf,RANGEDEL]
  000006:[e#13,RANGEDEL-z#inf,RANGEDEL]
L1:
  000007:[a#11,SET-c#11,SET]
L2:
  000008:[x#10,SET-x#10,SET]

wait-pending-table-stats
000005
----
num-entries: 1
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 467

wait-pending-table-stats
000006
----
num-entries: 1
num-deletions: 1
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 456

wait-pending-table-stats
000004
----
num-entries: 2
num-deletions: 2
num-range-key-sets: 0
point-deletions-bytes-estimate: 0
range-deletions-bytes-estimate: 923

define
L1
  a#11,RANGEDEL:d
  a#11,MERGE:1
  a#10,SET:2
  b#11,SET:1
  c#11,SET:1
----
mem: 1
L1:
  000004:[a#11,RANGEDEL-d#inf,RANGEDEL]

get seq=12
a
----
a:1
