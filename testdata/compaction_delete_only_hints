# The first few cases are adapted from this ASCII example. The y-axis is
# sequence numbers and the x-axis is the user key space. LSM levels are
# omitted from the visualization.
#
# 250
#       +--------00004 (fragmented)------+
#       V                                |
#       |-b...230:h-|                    |
# _______________________________________V_____________ snapshot #210
# 200               |--h#200,RANGEDEL:r--|
#
# _____________________________________________________ snapshot #180
#
# 150                     +--------+
#           +---------+   | 000006 |
#           | 000005  |   |        |
#           +_________+   |        |
# 100_____________________|________|___________________ snapshot #100
#                         +--------+
# _____________________________________________________ snapshot #70
#                             +---------------+
#  50                         | 000007        |
#                             |               |
#                             +---------------+
# ______________________________________________________________
#     a b c d e f g h i j k l m n o p q r s t u v w x y z

define snapshots=(70, 100, 180, 210)
L0
b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
----
L0.0:
  000004:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000005:[d#110,SET-i#140,SET]
L3:
  000006:[k#90,SET-o#150,SET]
L4:
  000007:[m#30,SET-u#60,SET]

# Test a hint that is blocked by open snapshots. No compaction should occur
# and the hint should not be removed.

get-hints
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}

maybe-compact
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}
Compactions:
(none)

# Adopt the same LSM but without snapshots 100, 180 and 210.

define snapshots=(70)
L0
b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
----
L0.0:
  000004:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000005:[d#110,SET-i#140,SET]
L3:
  000006:[k#90,SET-o#150,SET]
L4:
  000007:[m#30,SET-u#60,SET]

get-hints
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}

maybe-compact
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}
Compactions:
(none)

# Verify that compaction correctly handles the presence of multiple
# overlapping hints which might delete a file multiple times. All of the
# resolvable hints should be removed.

define
L0
a#300,RANGEDEL:k
L1
b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
----
L0.0:
  000004:[a#300,RANGEDEL-k#inf,RANGEDEL]
L1:
  000005:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000006:[d#110,SET-i#140,SET]
L3:
  000007:[k#90,SET-o#150,SET]
L4:
  000008:[m#30,SET-u#60,SET]

get-hints
----
Tombstoned spans:
[a, k) = {point=300}
[k, r) = {point=200}

maybe-compact
----
Tombstoned spans:
[a, k) = {point=300}
[k, r) = {point=200}
Compactions:
[JOB 100] compacted(delete-only) L2 [000000] (666B) Score=0.00 -> L2 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L3 [000000] (666B) Score=0.00 -> L3 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) [excise] L1 [000000] (649B) Score=0.00 -> L1 [000000] (1B), in 1.0s (2.0s total), output rate 1B/s
[JOB 100] compacted(delete-only) [excise] L4 [000000] (666B) Score=0.00 -> L4 [000000] (94B), in 1.0s (2.0s total), output rate 94B/s
[JOB 100] compacted(virtual-sst-rewrite) L1 [000000] (1B) Score=0.00 + L1 [] (0B) Score=0.00 -> L1 [000000] (643B), in 1.0s (2.0s total), output rate 643B/s
[JOB 100] compacted(virtual-sst-rewrite) L4 [000000] (94B) Score=0.00 + L4 [] (0B) Score=0.00 -> L4 [000000] (655B), in 1.0s (2.0s total), output rate 655B/s

# Test a range tombstone that is already compacted into L6.

define snapshots=(70)
L0
m#300,SET:m b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
----
L0.0:
  000004:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000005:[d#110,SET-i#140,SET]
L3:
  000006:[k#90,SET-o#150,SET]
L4:
  000007:[m#30,SET-u#60,SET]

get-hints
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}

compact a-z
----
L5:
  000010:[b#230,RANGEDEL-u#0,SET]

maybe-compact
----
Pending:
  L0.000004 [b, r) seqnums{point=[#200-#230]}
Compactions:
(none)

# The same test case, without snapshots, with a table (000008) that exists
# within the range del user key bounds, but above it in the LSM.

define
L1
b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
L0
e#240,SET:e m#260,SET:m
----
L0.0:
  000008:[e#240,SET-m#260,SET]
L1:
  000004:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000005:[d#110,SET-i#140,SET]
L3:
  000006:[k#90,SET-o#150,SET]
L4:
  000007:[m#30,SET-u#60,SET]

get-hints
----
Tombstoned spans:
[b, r) = {point=200}

# Tables 000005 and 000006 can be deleted as their largest sequence numbers fall
# below the smallest sequence number of the range del. Table 000007 falls
# outside the user key bounds, and table 000008 exists at a sequence number
# above the range del, so neither are deleted.

maybe-compact
----
Tombstoned spans:
[b, r) = {point=200}
Compactions:
[JOB 100] compacted(delete-only) L2 [000000] (666B) Score=0.00 -> L2 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L3 [000000] (666B) Score=0.00 -> L3 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) [excise] L4 [000000] (666B) Score=0.00 -> L4 [000000] (94B), in 1.0s (2.0s total), output rate 94B/s
[JOB 100] compacted(virtual-sst-rewrite) L4 [000000] (94B) Score=0.00 + L4 [] (0B) Score=0.00 -> L4 [000000] (655B), in 1.0s (2.0s total), output rate 655B/s

# A deletion hint present on an sstable in a higher level should NOT result in a
# deletion-only compaction incorrectly removing an sstable in L6 following an
# elision-only compaction that zeroes the sequence numbers in an L6 table.
#
# This is a regression test for pebble#1285.

# Create an sstable at L6. We expect that the SET survives the following
# sequence of compactions.
define snapshots=(10, 25)
L6
a#20,SET:b a#15,RANGEDEL:z
----
L6:
  000004:[a#20,SET-z#inf,RANGEDEL]

# Note that this test depends on stats being present on the sstables, so we
# collect hints here. We expect none, as the table is in L6.
get-hints
----
(none)

# Construct a scenario with tables containing a mixture of range dels and range
# key dels that sit within different types of hints.
#
#   +------- 000013 (internally fragmented spans) ----|
#   |                                                 V
#   |                       |-------------------------| m.RANGEKEYDEL:z
#   |               |-------|                           i.RANGEKEYDEL:m
#   V         |-----------------------|                 f.RANGEDEL:r
#   |---------|                                         a.RANGEDEL:f
#               +-+             +---+             +---+
#               | | 000006      |   | 000009      |   | 000012 <- Point keys only.
#               +-+             +---+             +---+
#         +---+           +---+             +---+
#         |   | 000005    |   | 000008      |   | 000011       <- Range keys only.
#         +---+           +---+             +---+
#   +---+           +---+             +---+
#   |   | 000004    |   | 000007      |   | 000010             <- Point and range keys.
#   +---+           +---+             +---+
# __________________________________________________________
#   a b c d e f g h i j k l m n o p q r s t u v w x y z
#
# Note that table 000013 contains both range dels and range key dels that have
# been internally fragmented. After defragmentation there are three hints
# created:
# - [a, i) - a point-key-only hint
# - [i, r) - a point-and-range-key hint
# - [r, z) - a range-key-only hint
#
# Based on the defragmented hints, the following tables can be deleted:
# - 000006: covered by range del hint [a, i), table contains only point keys.
# - 000007: covered by mixed hint [i, r), table contains point and range keys.
# - 000008: covered by mixed hint [i, r), table contains only range keys.
# - 000009: covered by mixed hint [i, r), table contains only point keys.
# - 000011: covered by range key hint [r, z), table contains only range keys.
#

# NOTE: the LSM shown in the example above is created bottom-up via ingestions.

reset
----

ingest ext
set a a
range-key-set a c @1 foo
set c c
----
OK

ingest ext
range-key-set d f @2 bar
----
OK

ingest ext
set g g
set h h
----
OK

ingest ext
set i i
range-key-set i k @1 v1
set k k
----
OK

ingest ext
range-key-set l n @2 bar
----
OK

ingest ext
set o o
set q q
----
OK

ingest ext
set r r
range-key-set r t @1 v1
set t t
----
OK

ingest ext
range-key-set u w @2 bar
----
OK

ingest ext
set x x
set z z
----
OK

ingest ext
del-range a f
del-range f r
range-key-del i m
range-key-del m z
----
OK

describe-lsm
----
L0.0:
  000013:[a#19,RANGEDEL-z#inf,RANGEKEYDEL]
L6:
  000004:[a#10,RANGEKEYSET-c#10,SET]
  000005:[d#11,RANGEKEYSET-f#inf,RANGEKEYSET]
  000006:[g#12,SET-h#12,SET]
  000007:[i#13,RANGEKEYSET-k#13,SET]
  000008:[l#14,RANGEKEYSET-n#inf,RANGEKEYSET]
  000009:[o#15,SET-q#15,SET]
  000010:[r#16,RANGEKEYSET-t#16,SET]
  000011:[u#17,RANGEKEYSET-w#inf,RANGEKEYSET]
  000012:[x#18,SET-z#18,SET]

get-hints
----
Tombstoned spans:
[a, i) = {point=19}
[i, r) = {point=19, range=19}
[r, z) = {range=19}

maybe-compact
----
Tombstoned spans:
[a, i) = {point=19}
[i, r) = {point=19, range=19}
[r, z) = {range=19}
Compactions:
[JOB 100] compacted(delete-only) L6 [000000] (661B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L6 [000000] (661B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L6 [000000] (696B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L6 [000000] (696B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L6 [000000] (796B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s

# Verify that a delete-only compaction can partially excise a file.

define
L0
a#300,RANGEDEL:k
L1
b#230,RANGEDEL:h h#200,RANGEDEL:r
L2
d#110,SET:d i#140,SET:i
L3
k#90,SET:k o#150,SET:o
L4
m#30,SET:m u#60,SET:u
----
L0.0:
  000004:[a#300,RANGEDEL-k#inf,RANGEDEL]
L1:
  000005:[b#230,RANGEDEL-r#inf,RANGEDEL]
L2:
  000006:[d#110,SET-i#140,SET]
L3:
  000007:[k#90,SET-o#150,SET]
L4:
  000008:[m#30,SET-u#60,SET]

get-hints
----
Tombstoned spans:
[a, k) = {point=300}
[k, r) = {point=200}

iter
first
next
----
u: (u, .)
.

maybe-compact
----
Tombstoned spans:
[a, k) = {point=300}
[k, r) = {point=200}
Compactions:
[JOB 100] compacted(delete-only) L2 [000000] (666B) Score=0.00 -> L2 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) L3 [000000] (666B) Score=0.00 -> L3 [] (0B), in 1.0s (2.0s total), output rate 0B/s
[JOB 100] compacted(delete-only) [excise] L1 [000000] (649B) Score=0.00 -> L1 [000000] (1B), in 1.0s (2.0s total), output rate 1B/s
[JOB 100] compacted(delete-only) [excise] L4 [000000] (666B) Score=0.00 -> L4 [000000] (94B), in 1.0s (2.0s total), output rate 94B/s
[JOB 100] compacted(virtual-sst-rewrite) L1 [000000] (1B) Score=0.00 + L1 [] (0B) Score=0.00 -> L1 [000000] (643B), in 1.0s (2.0s total), output rate 643B/s
[JOB 100] compacted(virtual-sst-rewrite) L4 [000000] (94B) Score=0.00 + L4 [] (0B) Score=0.00 -> L4 [000000] (655B), in 1.0s (2.0s total), output rate 655B/s

describe-lsm
----
L0.0:
  000004:[a#300,RANGEDEL-k#inf,RANGEDEL]
L1:
  000010:[k#200,RANGEDEL-r#inf,RANGEDEL]
L4:
  000012:[u#0,SET-u#0,SET]

iter
first
next
----
u: (u, .)
.

get-hints
----
(none)

# Verify that a delete-only compaction hint for point keys does not excise a file
# if it has range keys

reset
----

ingest ext
set k k
set o o
range-key-set k o @3 foo
----
OK

ingest ext
set d d
set i i
----
OK

ingest ext
del-range b r
----
OK

describe-lsm
----
L0.0:
  000006:[b#12,RANGEDEL-r#inf,RANGEDEL]
L6:
  000005:[d#11,SET-i#11,SET]
  000004:[k#10,RANGEKEYSET-o#10,SET]

get-hints
----
Tombstoned spans:
[b, r) = {point=12}

iter
first
----
.

maybe-compact
----
Tombstoned spans:
[b, r) = {point=12}
Compactions:
[JOB 100] compacted(delete-only) L6 [000000] (661B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s

describe-lsm
----
L0.0:
  000006:[b#12,RANGEDEL-r#inf,RANGEDEL]
L6:
  000004:[k#10,RANGEKEYSET-o#10,SET]

iter
first
----
.

get-hints
----
(none)

# Verify that a delete-only compaction hint can excise a file twice.

reset
----

ingest ext
set k k
set ll mm
set m m
set o o
range-key-set k o @3 foo
----
OK

ingest ext
del-range b l
del-range m p
range-key-del b l
range-key-del m p
----
OK

describe-lsm
----
L0.0:
  000005:[b#11,RANGEKEYDEL-p#inf,RANGEDEL]
L6:
  000004:[k#10,RANGEKEYSET-o#10,SET]

get-hints
----
Tombstoned spans:
[b, l) = {point=11, range=11}
[m, p) = {point=11, range=11}

iter
first
next
----
ll: (mm, .)
.

maybe-compact
----
Tombstoned spans:
[b, l) = {point=11, range=11}
[m, p) = {point=11, range=11}
Compactions:
[JOB 100] compacted(delete-only) [excise] L6 [000000] (810B) Score=0.00 -> L6 [000000] (93B), in 1.0s (2.0s total), output rate 93B/s
[JOB 100] compacted(delete-only) [excise] L6 [000000] (93B) Score=0.00 -> L6 [000000] (93B), in 1.0s (2.0s total), output rate 93B/s
[JOB 100] compacted(virtual-sst-rewrite) L6 [000000] (93B) Score=0.00 + L6 [] (0B) Score=0.00 -> L6 [000000] (788B), in 1.0s (2.0s total), output rate 788B/s

describe-lsm
----
L0.0:
  000005:[b#11,RANGEKEYDEL-p#inf,RANGEDEL]
L6:
  000008:[l#10,RANGEKEYSET-m#inf,RANGEKEYSET]

iter
first
next
----
ll: (mm, .)
.

get-hints
----
(none)

# Verify that a delete-only compaction hint does not apply if it increases
# sstable count.

reset
----

ingest ext
set k k
set ll mm
set m m
set o o
range-key-set k o @3 foo
----
OK

ingest ext
del-range l m
range-key-del l m
----
OK

describe-lsm
----
L0.0:
  000005:[l#11,RANGEKEYDEL-m#inf,RANGEDEL]
L6:
  000004:[k#10,RANGEKEYSET-o#10,SET]

get-hints
----
(none)

iter
first
next
next
next
----
k: (k, .)
m: (m, .)
o: (o, .)
.

maybe-compact
----
(none)
Compactions:
(none)

describe-lsm
----
L0.0:
  000005:[l#11,RANGEKEYDEL-m#inf,RANGEDEL]
L6:
  000004:[k#10,RANGEKEYSET-o#10,SET]

iter
first
next
next
next
----
k: (k, .)
m: (m, .)
o: (o, .)
.

get-hints
----
(none)

# Reset the database.

reset
----

# Simulate an ingestion of a CockroachDB snapshot sstable with a range delete and a
# range key delete covering the keyspace.

ingest ext
set c c
set d d
set e e
set f f
set g g
del-range c h
range-key-del c h
----
OK

describe-lsm
----
L6:
  000004:[c#10,RANGEKEYDEL-h#inf,RANGEDEL]

snapshot
----
snapshot seqnum: 11

# Simulate a replica removal of the previously ingested snapshot through a range
# delete and range key delete.

batch
del-range c h
range-key-del c h
----

flush
----
L0.0:
  000006:[c#12,RANGEKEYDEL-h#inf,RANGEDEL]
L6:
  000004:[c#10,RANGEKEYDEL-h#inf,RANGEDEL]

get-hints
----
Pending:
  L0.000006 [c, h) seqnums{point=[#11-#11], range=[#12-#12]}

close-snapshot
11
----
[JOB 100] compacted(delete-only) L6 [000000] (867B) Score=0.00 -> L6 [] (0B), in 1.0s (2.0s total), output rate 0B/s
