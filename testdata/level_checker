# Format for define command:
# Levels are ordered from higher to lower, and each new level starts with an L
# Each level is defined using an even number of lines where every pair of lines represents
# a file. The files within a level are ordered from smaller to larger keys.
# Each file is defined using: the first line specifies the smallest and largest internal
# keys and the second line the point key-value pairs in the sstable in order. The rangedel
# key-value pairs should also be in increasing order relative to the other rangedel pairs.
# The largest file key can take the form of <userkey>.RANGEDEL.inf, which
# represents the range deletion sentinel.
#
# Many of the correct case definitions are borrowed from merging_iter since it defines
# some tricky configurations.

# The untruncated range tombstone at the higher level does not overlap with the lower level once
# we consider the file boundaries, which is why its lower sequence number is ok.
define
L
a#30,SET e#inf,RANGEDEL
a#30,SET:30 c#27,SET:27 Span:a-f:{(#8,RANGEDEL)}
L
e#10,SET g#20,SET
e#10,SET:10 g#20,SET:20 Span:e-f:{(#8,RANGEDEL)}
----
Level 1
  file 0: [a#30,SET-e#inf,RANGEDEL]
Level 2
  file 0: [e#10,SET-g#20,SET]

check
----

# The untruncated range tombstone at the higher level does not overlap with the g point at the
# lower level once we consider the file boundaries, which is why its lower sequence number is ok.
define
L
a#15,SET f#16,SET
a#15,SET:15 c#13,SET:13 f#16,SET:16 Span:a-h:{(#12,RANGEDEL)}
L
e#10,SET g#15,SET
e#10,SET:10 g#15,SET:15
----
Level 1
  file 0: [a#15,SET-f#16,SET]
Level 2
  file 0: [e#10,SET-g#15,SET]

check
----

# The untruncated range tombstones in both levels do not overlap once we consider the file
# boundaries (which are non-overlapping).
define
L
c#30,SET f#0,RANGEDEL
c#30,SET:30 d#27,SET:27 Span:a-f:{(#8,RANGEDEL)}
L
a#10,SET c#inf,RANGEDEL
a#10,SET:10 b#12,SET:12 Span:a-f:{(#8,RANGEDEL)}
----
Level 1
  file 0: [c#30,SET-f#0,RANGEDEL]
Level 2
  file 0: [a#10,SET-c#inf,RANGEDEL]

check
----

# The range tombstone in the higher level does not overlap with the b point in the lower level,
# which has a higher sequence number, when we consider the file boundaries.
define
L
c#15,SET g#16,SET
c#15,SET:15 f#13,SET:13 g#16,SET:16 Span:a-h:{(#12,RANGEDEL)}
L
b#14,SET d#10,SET
b#14,SET:14 d#10,SET:10
----
Level 1
  file 0: [c#15,SET-g#16,SET]
Level 2
  file 0: [b#14,SET-d#10,SET]

check
----

# The two files do not overlap despite the seeming overlap of the range tombstones.
define
L
a#30,SET e#inf,RANGEDEL
a#30,SET:30 c#27,SET:27 Span:a-g:{(#8,RANGEDEL)}
L
e#10,SET g#20,SET
e#10,SET:10 g#20,SET:20 Span:e-g:{(#8,RANGEDEL)}
----
Level 1
  file 0: [a#30,SET-e#inf,RANGEDEL]
Level 2
  file 0: [e#10,SET-g#20,SET]

check
----

define
L
a#30,SET e#inf,RANGEDEL
a#30,SET:30 c#27,SET:27 Span:a-g:{(#8,RANGEDEL)}
L
a#10,SET g#20,SET
a#10,SET:10 c#28,SET:28 g#20,SET:20
----
Level 1
  file 0: [a#30,SET-e#inf,RANGEDEL]
Level 2
  file 0: [a#10,SET-g#20,SET]

check
----
found InternalKey c#27,SET in L1: fileNum=000010 and InternalKey c#28,SET in L2: fileNum=000011

# The sentinel key for the RANGEDEL should not violate g having a higher seq num at a
# lower level.
define
L
a#30,SET g#inf,RANGEDEL
a#30,SET:30 c#27,SET:27 Span:a-g:{(#8,RANGEDEL)}
L
g#10,SET j#20,SET
g#10,SET:10 j#20,SET:20
----
Level 1
  file 0: [a#30,SET-g#inf,RANGEDEL]
Level 2
  file 0: [g#10,SET-j#20,SET]

check
----

define
L
a#30,SET g#8,SET
a#30,SET:30 c#27,SET:27 Span:a-g:{(#8,RANGEDEL)} g#8,SET:8
L
g#10,SET j#20,SET
g#10,SET:10 j#20,SET:20
----
Level 1
  file 0: [a#30,SET-g#8,SET]
Level 2
  file 0: [g#10,SET-j#20,SET]

check
----
found InternalKey g#8,SET in L1: fileNum=000014 and InternalKey g#10,SET in L2: fileNum=000015

define
L
a#30,SET g#30,SET
a#30,SET:30 c#8,SET:8 g#30,SET:30
L
a#10,SET j#20,SET
a#10,SET:10 j#20,SET:20 Span:b-g:{(#10,RANGEDEL)}
----
Level 1
  file 0: [a#30,SET-g#30,SET]
Level 2
  file 0: [a#10,SET-j#20,SET]

check
----
tombstone b-g:{(#10,RANGEDEL)} in L2: fileNum=000017 deletes key c#8,SET in L1: fileNum=000016

define
L
a#8,RANGEDEL c#inf,RANGEDEL
Span:a-c:{(#8,RANGEDEL)}
L
a#6,RANGEDEL d#inf,RANGEDEL
Span:a-d:{(#6,RANGEDEL)} Span:b-c:{(#10,RANGEDEL)}
----
Level 1
  file 0: [a#8,RANGEDEL-c#inf,RANGEDEL]
Level 2
  file 0: [a#6,RANGEDEL-d#inf,RANGEDEL]

check
----
encountered tombstone b-c:{(#8,RANGEDEL)} in L1: fileNum=000018 that has a lower seqnum than the same tombstone in L2: fileNum=000019

# Check incorrect ordering of point keys in an sstable.
define disable-key-order-checks
L
a#3,SET e#4,SET
e#4,SET:e a#3,SET:a
L
d#1,SET f#2,SET
d#1,SET:d f#2,SET:f
----
Level 1
  file 0: [a#3,SET-e#4,SET]
Level 2
  file 0: [d#1,SET-f#2,SET]

check
----
out of order keys e#4,SET >= a#3,SET in L1: fileNum=000020

# Check successive sstables on a level are ordered.
define disable-key-order-checks
L
a#1,SET b#2,SET
a#1,SET:a b#2,SET:b
b#3,SET c#4,SET
b#3,SET:b c#4,SET:c
----
Level 1
  file 0: [a#1,SET-b#2,SET]
  file 1: [b#3,SET-c#4,SET]

check
----
out of order keys b#2,SET >= b#3,SET in L1: fileNum=000023

# Check range delete keys are fragmented and ordered in an sstable having
# rangeDelV2 formatted range delete blocks.

# Case 1: Fragmented but not ordered.
define write-unfragmented disable-key-order-checks
L
a#1,RANGEDEL g#inf,RANGEDEL
Span:d-e:{(#2,RANGEDEL)-(#1,RANGEDEL)} Span:f-g:{(#3,RANGEDEL)} Span:a-b:{(#4,RANGEDEL)}
----
Level 1
  file 0: [a#1,RANGEDEL-g#inf,RANGEDEL]

check
----
unordered or unfragmented range delete tombstones f-g:{(#3,RANGEDEL)}, a-b:{(#4,RANGEDEL)} in L1: fileNum=000024

# Case 2: Ordered but not fragmented.
define write-unfragmented disable-key-order-checks
L
a#1,RANGEDEL d#inf,RANGEDEL
Span:a-d:{(#1,RANGEDEL)} Span:b-c:{(#2,RANGEDEL)}
----
Level 1
  file 0: [a#1,RANGEDEL-d#inf,RANGEDEL]

check
----
unordered or unfragmented range delete tombstones a-d:{(#1,RANGEDEL)}, b-c:{(#2,RANGEDEL)} in L1: fileNum=000025

# Case 3: Verify check is done before truncation.
define write-unfragmented disable-key-order-checks
L
a#1,RANGEDEL b#inf,RANGEDEL
Span:a-z:{(#1,RANGEDEL)} Span:d-e:{(#2,RANGEDEL)}
----
Level 1
  file 0: [a#1,RANGEDEL-b#inf,RANGEDEL]

check
----
unordered or unfragmented range delete tombstones a-z:{(#1,RANGEDEL)}, d-e:{(#2,RANGEDEL)} in L1: fileNum=000026

# Merge record processing.

# Case 1: Latest versions of a key are MERGE records and processing one of
# them fails.
define
L
a#10,MERGE a#9,MERGE
a#10,MERGE:10 a#9,MERGE:fail-merge
----
Level 1
  file 0: [a#10,MERGE-a#9,MERGE]

check merger=fail-merger
----
merge processing error on key a#9,MERGE in L1: fileNum=000027: merge failed

# Case 2: Last checked key is a MERGE record.
define
L
a#10,MERGE a#9,MERGE
a#10,MERGE:10 a#9,MERGE:fail-finish
----
Level 1
  file 0: [a#10,MERGE-a#9,MERGE]

check merger=fail-merger
----
merge processing error on key a#9,MERGE in L1: fileNum=000028: finish failed

# Case 3: MERGE records succeeded by newer versions of a key are also
# processed.
define
L
a#10,MERGE a#3,SINGLEDEL
a#10,MERGE:10 a#9,MERGE:9 a#8,SET:8 a#7,MERGE:7 a#6,MERGE:6 a#5,DEL: a#4,MERGE:fail-finish a#3,SINGLEDEL:
----
Level 1
  file 0: [a#10,MERGE-a#3,SINGLEDEL]

check merger=fail-merger
----
merge processing error on key a#3,SINGLEDEL in L1: fileNum=000029: finish failed

# Case 4: Finish processing on key change.
define
L
a#10,MERGE b#11,SET
a#10,MERGE:10 a#9,MERGE:fail-finish b#11,SET:11
----
Level 1
  file 0: [a#10,MERGE-b#11,SET]

check merger=fail-merger
----
merge processing error on key b#11,SET in L1: fileNum=000030: finish failed

# Case 5: SET finishes MERGE record processing.
define
L
a#10,MERGE a#9,SET
a#10,MERGE:10 a#9,SET:fail-finish
----
Level 1
  file 0: [a#10,MERGE-a#9,SET]

check merger=fail-merger
----
merge processing error on key a#9,SET in L1: fileNum=000031: finish failed

# Case 6: DEL finishes MERGE record processing.
define
L
a#10,MERGE a#9,DEL
a#10,MERGE:fail-finish a#9,DEL:
----
Level 1
  file 0: [a#10,MERGE-a#9,DEL]

check merger=fail-merger
----
merge processing error on key a#9,DEL in L1: fileNum=000032: finish failed

# Case 7: SINGLEDEL finishes MERGE record processing.
define
L
a#10,MERGE a#9,SINGLEDEL
a#10,MERGE:fail-finish a#9,SINGLEDEL:
----
Level 1
  file 0: [a#10,MERGE-a#9,SINGLEDEL]

check merger=fail-merger
----
merge processing error on key a#9,SINGLEDEL in L1: fileNum=000033: finish failed

# Test a case where we pause at a range deletion end boundary at the end of a
# file and the last point key of the same file has its value stored out-of-band
# in a value block (because it's the second key with the same prefix 'a').

define
L
a@9#9,SET f#inf,RANGEDEL
a@9#9,SET:a9 a@6#6,SET:a6 Span:a-f:{(#5,RANGEDEL)}
f@6#6,SET f@6#6,SET
f@6#6,SET:f6
----
Level 1
  file 0: [a@9#9,SET-f#inf,RANGEDEL]
  file 1: [f@6#6,SET-f@6#6,SET]

check
----
