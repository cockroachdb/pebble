define
a#1,SET:b
----

iter
first
next
----
a#1,SET:b
.

define
a#2,SET:c
a#1,SET:b
----

iter
first
next
----
a#2,SET:c
.

iter snapshots=0
first
next
----
a#2,SET:c
.

iter snapshots=1
first
next
----
a#2,SET:c
.

iter snapshots=2
first
next
next
----
a#2,SET:c
a#1,SET:b
.

define
a#2,DEL:
a#1,SET:b
----

iter
first
next
----
a#2,DEL:
.

iter elide-tombstones=true
first
----
.

iter elide-tombstones=true snapshots=2
first
next
next
----
a#2,DEL:
a#1,SET:b
.

iter elide-tombstones=true snapshots=1
first
next
----
a#2,DEL:
.

define
a#2,DEL:
a#1,SET:b
b#3,SET:c
----

iter
first
next
next
----
a#2,DEL:
b#3,SET:c
.

iter snapshots=1
first
next
next
----
a#2,DEL:
b#3,SET:c
.

iter snapshots=2
first
next
next
next
----
a#2,DEL:
a#1,SET:b
b#3,SET:c
.

define
a#1,SET:a
b#2,SET:b
c#3,SET:c
----

iter
first
next
next
next
----
a#1,SET:a
b#2,SET:b
c#3,SET:c
.

define
a#3,MERGE:d
a#2,MERGE:c
a#1,SET:b
b#2,MERGE:b
b#1,MERGE:a
----

iter
first
next
next
----
a#3,SET:bcd[base]
b#2,MERGE:ab
.

iter snapshots=3 print-snapshot-pinned print-force-obsolete
first
next
next
next
----
a#3,MERGE:d (not pinned) (not force obsolete)
a#2,SET:bc[base] (pinned) (not force obsolete)
b#2,MERGE:ab (not pinned) (not force obsolete)
.

define
a#9,SET:b
a#8,DEL:
a#7,SET:d
a#6,DEL:
a#5,SET:f
----

iter
first
next
----
a#9,SETWITHDEL:b
.

iter snapshots=6
first
next
next
----
a#9,SETWITHDEL:b
a#5,SET:f
.

iter snapshots=7
first
next
next
----
a#9,SETWITHDEL:b
a#6,DEL:
.

iter snapshots=8
first
next
next
----
a#9,SETWITHDEL:b
a#7,SETWITHDEL:d
.

iter snapshots=9
first
next
next
----
a#9,SET:b
a#8,DEL:
.

iter snapshots=10
first
next
----
a#9,SETWITHDEL:b
.

iter snapshots=(5,6,7,8,9)
first
next
next
next
next
next
----
a#9,SET:b
a#8,DEL:
a#7,SET:d
a#6,DEL:
a#5,SET:f
.

define
a#2,INVALID:b
a#1,SET:c
----

iter
first
----
err=invalid internal key kind: INVALID

define
a#2,SET:b
a#1,INVALID:c
----

iter
first
----
err=invalid internal key kind: INVALID

define
a#2,MERGE:b
a#1,INVALID:c
----

iter
first
----
err=invalid internal key kind: INVALID

define
a#2,INVALID:c
a#1,RANGEDEL:d
----

iter
first
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#1,RANGEDEL)}
err=invalid internal key kind: INVALID

define
a#2,MERGE:b
a#1,MERGE:c
a#0,MERGE:d
----

iter snapshots=(1,2) print-snapshot-pinned print-force-obsolete
first
next
next
next
----
a#2,MERGE:b (not pinned) (not force obsolete)
a#1,MERGE:c (pinned) (not force obsolete)
a#0,MERGE:d (pinned) (not force obsolete)
.

define
a#2,SET:b
a#1,RANGEDEL:c
b#4,RANGEDEL:d
b#2,SET:e
c#3,SET:f
----

iter
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#1,RANGEDEL)}
a#2,SET:b
b#inf,RANGEDEL:; Span() = b-c:{(#4,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#4,RANGEDEL)}
.

iter snapshots=2
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#1,RANGEDEL)}
a#2,SET:b
b#inf,RANGEDEL:; Span() = b-c:{(#4,RANGEDEL) (#1,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#4,RANGEDEL)}
.

iter snapshots=3 print-snapshot-pinned print-force-obsolete
first
next
next
next
next
next
----
a#inf,RANGEDEL: (not pinned) (not force obsolete); Span() = a-b:{(#1,RANGEDEL)}
a#2,SET:b (not pinned) (not force obsolete)
b#inf,RANGEDEL: (not pinned) (not force obsolete); Span() = b-c:{(#4,RANGEDEL) (#1,RANGEDEL)}
b#2,SET:e (pinned) (force obsolete)
c#inf,RANGEDEL: (not pinned) (force obsolete); Span() = c-d:{(#4,RANGEDEL)}
.

iter snapshots=4 print-snapshot-pinned print-force-obsolete
first
next
next
next
next
next
next
----
a#inf,RANGEDEL: (not pinned) (not force obsolete); Span() = a-b:{(#1,RANGEDEL)}
a#2,SET:b (not pinned) (not force obsolete)
b#inf,RANGEDEL: (not pinned) (not force obsolete); Span() = b-c:{(#4,RANGEDEL) (#1,RANGEDEL)}
b#2,SET:e (pinned) (force obsolete)
c#inf,RANGEDEL: (not pinned) (force obsolete); Span() = c-d:{(#4,RANGEDEL)}
c#3,SET:f (pinned) (force obsolete)
.

define
a#3,RANGEDEL:e
b#4,SET:b
c#3,SET:c
d#2,SET:d
e#1,SET:e
----

iter
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-e:{(#3,RANGEDEL)}
b#4,SET:b
c#3,SET:c
e#1,SET:e
.

define
a#3,RANGEDEL:e
b#4,MERGE:b
c#3,MERGE:c
d#2,MERGE:d
e#1,MERGE:e
----

iter
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-e:{(#3,RANGEDEL)}
b#4,MERGE:b
c#3,MERGE:c
e#1,MERGE:e
.

define
a#3,RANGEDEL:c
b#5,MERGE:e
b#4,MERGE:d
b#2,MERGE:c
b#1,MERGE:b
d#5,MERGE:c
d#4,MERGE:b
d#3,RANGEDEL:f
d#2,MERGE:e
d#1,MERGE:d
----

iter
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#5,MERGE:de
d#inf,RANGEDEL:; Span() = d-f:{(#3,RANGEDEL)}
d#5,MERGE:bc
.

define
a#3,RANGEDEL:d
b#2,RANGEDEL:e
c#1,RANGEDEL:f
----

iter
first
next
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#3,RANGEDEL)}
b#inf,RANGEDEL:; Span() = b-c:{(#3,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#2,RANGEDEL)}
e#inf,RANGEDEL:; Span() = e-f:{(#1,RANGEDEL)}
.

iter snapshots=2
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#3,RANGEDEL)}
b#inf,RANGEDEL:; Span() = b-c:{(#3,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL) (#1,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#2,RANGEDEL) (#1,RANGEDEL)}

iter snapshots=3
first
next
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#3,RANGEDEL)}
b#inf,RANGEDEL:; Span() = b-c:{(#3,RANGEDEL) (#2,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL) (#2,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#2,RANGEDEL)}
e#inf,RANGEDEL:; Span() = e-f:{(#1,RANGEDEL)}
.

iter snapshots=(2,3)
first
next
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#3,RANGEDEL)}
b#inf,RANGEDEL:; Span() = b-c:{(#3,RANGEDEL) (#2,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL) (#2,RANGEDEL) (#1,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#2,RANGEDEL) (#1,RANGEDEL)}
e#inf,RANGEDEL:; Span() = e-f:{(#1,RANGEDEL)}
.

define
a#10,RANGEDEL:k
f#9,SET:f
f#8,SET:f
----

iter snapshots=(9,10) print-snapshot-pinned print-force-obsolete
first
next
next
----
a#inf,RANGEDEL: (not pinned) (not force obsolete); Span() = a-k:{(#10,RANGEDEL)}
f#9,SET:f (pinned) (force obsolete)
f#8,SET:f (pinned) (force obsolete)

define
f#10,RANGEDEL:k
f#9,SET:f
f#8,SET:f
----

iter snapshots=(9,10)
first
next
next
----
f#inf,RANGEDEL:; Span() = f-k:{(#10,RANGEDEL)}
f#9,SET:f
f#8,SET:f

define
a#1,SET:a
b#2,RANGEDEL:d
c#3,RANGEDEL:e
d#4,SET:d
----

iter
first
next
next
next
next
next
----
a#1,SET:a
b#inf,RANGEDEL:; Span() = b-c:{(#2,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#3,RANGEDEL)}
d#4,SET:d
.

iter snapshots=3
first
next
next
next
next
next
----
a#1,SET:a
b#inf,RANGEDEL:; Span() = b-c:{(#2,RANGEDEL)}
c#inf,RANGEDEL:; Span() = c-d:{(#3,RANGEDEL) (#2,RANGEDEL)}
d#inf,RANGEDEL:; Span() = d-e:{(#3,RANGEDEL)}
d#4,SET:d
.

define
a#1,SET:a
b#2,RANGEDEL:d
c#4,SET:d
----

iter
first
next
next
next
----
a#1,SET:a
b#inf,RANGEDEL:; Span() = b-d:{(#2,RANGEDEL)}
c#4,SET:d
.

define
a#2,RANGEDEL:d
a#2,SET:a
b#2,SET:b
c#2,SET:c
----

iter
first
next
next
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#2,RANGEDEL)}
a#2,SET:a
b#2,SET:b
c#2,SET:c
.

define
a#1,SINGLEDEL:
----

iter
first
next
----
a#1,SINGLEDEL:
.

iter elide-tombstones=true
first
----
.
ineffectual-single-deletes: a

define
a#2,SINGLEDEL:
a#1,SINGLEDEL:
----

iter
first
next
----
a#2,SINGLEDEL:
.
ineffectual-single-deletes: a

define
a#3,SINGLEDEL:
a#2,SINGLEDEL:
a#1,SET:a
----

iter
first
----
.
ineffectual-single-deletes: a

define
a#3,SET:a
b#2,SINGLEDEL:
b#1,DEL:
----

iter
first
next
next
----
a#3,SET:a
b#2,DEL:
.
ineffectual-single-deletes: b

define
a#2,SINGLEDEL:
a#1,DEL:
----

iter
first
next
----
a#2,DEL:
.
ineffectual-single-deletes: a

iter elide-tombstones=true
first
----
.
ineffectual-single-deletes: a

define
a#2,SINGLEDEL:
a#1,MERGE:a
----

iter
first
----
.

iter elide-tombstones=true
first
----
.

define
a#2,SINGLEDEL:
a#1,SET:b
----

iter
first
----
.

# SET that meets a SINGLEDEL is transformed into a SETWITHDEL.

define
a#2,SET:b
a#1,SINGLEDEL:
----

iter
first
next
----
a#2,SETWITHDEL:b
.

# We don't notice the ineffectual single delete since the SET causes all
# SingleDelete error checking to be skipped.
iter elide-tombstones=true
first
next
----
a#2,SETWITHDEL:b
.

define
a#6,MERGE:b
a#5,SINGLEDEL:
a#4,SET:a
----

iter
first
next
----
a#6,SETWITHDEL:b[base]
.

# Non-deterministic use of SINGLEDEL where there are two older SETs that have
# not been deleted or single deleted. It is permitted to shadow both, since
# MERGE turns into a SETWITHDELETE when it meets the SINGLEDEL.
define
a#6,MERGE:b
a#5,SINGLEDEL:
a#4,SET:a
a#3,SET:a
----

iter
first
next
----
a#6,SETWITHDEL:b[base]
.

define
a#2,SINGLEDEL:
a#1,SET:b
b#3,SET:c
----

iter
first
next
----
b#3,SET:c
.

define
a#3,SINGLEDEL:
a#2,SET:b
a#1,SET:a
----

iter
first
next
----
a#1,SET:a
.
invariant-violation-single-deletes: a

define
a#3,SINGLEDEL:
a#2,MERGE:b
a#1,MERGE:a
----

# SINGLEDEL consumes the first MERGE.
iter
first
next
----
a#1,MERGE:a
.
invariant-violation-single-deletes: a

define
a#4,SINGLEDEL:
a#3,SET:val
a#2,SINGLEDEL:
a#1,SET:val
----

iter
first
----
.

iter snapshots=2
first
next
next
----
a#2,SINGLEDEL:
a#1,SET:val
.

define
a#4,SINGLEDEL:
a#3,SET:val
a#2,DEL:
a#1,SET:val
----

iter
first
next
----
a#2,DEL:
.

iter snapshots=2
first
next
next
----
a#2,DEL:
a#1,SET:val
.

iter snapshots=3
first
next
----
a#2,DEL:
.

iter snapshots=(2,3)
first
next
next
----
a#2,DEL:
a#1,SET:val
.

define
a#4,SINGLEDEL:
a#3,SET:c
a#2,MERGE:b
a#1,SET:a
----

iter
first
next
----
a#2,SET:ab[base]
.
invariant-violation-single-deletes: a

iter snapshots=2
first
next
next
----
a#2,MERGE:b
a#1,SET:a
.
invariant-violation-single-deletes: a

iter snapshots=3
first
next
----
a#2,SET:ab[base]
.
invariant-violation-single-deletes: a

iter snapshots=(2,3,4)
first
next
next
next
next
----
a#4,SINGLEDEL:
a#3,SET:c
a#2,MERGE:b
a#1,SET:a
.

define
a#3,SINGLEDEL:
a#2,RANGEDEL:c
a#1,SET:val
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#2,RANGEDEL)}
a#3,SINGLEDEL:
.

define
a#3,RANGEDEL:d
a#2,DEL:
a#1,SET:a
d#2,DEL:
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#3,RANGEDEL)}
d#2,DEL:
.

iter snapshots=3
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#3,RANGEDEL)}
a#2,DEL:
d#2,DEL:
.

iter snapshots=2
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#3,RANGEDEL)}
a#1,SET:a
d#2,DEL:
.

iter snapshots=1
first
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#3,RANGEDEL)}
d#2,DEL:
.

define
a#2,MERGE:a
b#1,RANGEDEL:c
----

iter
first
next
next
----
a#2,MERGE:a
b#inf,RANGEDEL:; Span() = b-c:{(#1,RANGEDEL)}
.

define
a#2,MERGE:v2
a#1,RANGEDEL:b
a#1,MERGE:v1
----

iter is-bottommost-layer=true
first
next
next
----
a#inf,RANGEDEL:; Span() = a-b:{(#1,RANGEDEL)}
a#0,SET:v1v2[base]
.

# Verify that we transform merge+del -> set.

define
a#5,MERGE:5
a#3,DEL:
a#1,MERGE:1
----

iter
first
next
----
a#5,SETWITHDEL:5[base]
.

iter is-bottommost-layer=true
first
next
----
a#0,SETWITHDEL:5[base]
.

iter elide-tombstones=true
first
next
----
a#5,SETWITHDEL:5[base]
.

iter snapshots=2
first
next
next
----
a#5,SETWITHDEL:5[base]
a#1,MERGE:1
.

iter snapshots=2 elide-tombstones=true
first
next
next
----
a#5,SETWITHDEL:5[base]
a#1,MERGE:1
.

# Verify that merge+rangedel -> merge.

define
a#3,RANGEDEL:c
b#5,MERGE:5
b#2,SET:2
b#1,MERGE:1
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#5,MERGE:5
.

iter is-bottommost-layer=true
first
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#0,SET:5[base]
.

iter snapshots=2
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#5,MERGE:5
b#1,MERGE:1
.

define
a#3,RANGEDEL:c
b#5,MERGE:5
b#2,MERGE:2
b#1,MERGE:1
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#5,MERGE:5
.

iter snapshots=2
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-c:{(#3,RANGEDEL)}
b#5,MERGE:5
b#1,MERGE:1
.

# SET that meets a DEL is transformed into a SETWITHDEL.

define
a#2,SET:b
a#1,DEL:
----

iter
first
next
----
a#2,SETWITHDEL:b
.

iter snapshots=2
first
next
next
----
a#2,SET:b
a#1,DEL:
.

define
a#3,SET:c
a#2,DEL:
a#1,SET:b
----

iter
first
next
----
a#3,SETWITHDEL:c
.

iter snapshots=2
first
next
next
----
a#3,SETWITHDEL:c
a#1,SET:b
.

define
a#3,SET:c
a#2,SET:b
a#1,DEL:
----

iter
first
next
----
a#3,SETWITHDEL:c
.

iter snapshots=3
first
next
next
----
a#3,SET:c
a#2,SETWITHDEL:b
.

iter snapshots=2
first
next
next
----
a#3,SET:c
a#1,DEL:
.

define
a#3,DEL:
a#2,SET:b
a#1,DEL:
----

iter
first
next
----
a#3,DEL:
.

iter snapshots=3
first
next
next
----
a#3,DEL:
a#2,SETWITHDEL:b
.

iter snapshots=2
first
next
next
----
a#3,DEL:
a#1,DEL:
.

# SETWITHDEL-eligible entries at or under a RANGEDEL at the same user key should
# be skipped.
define
a#3,SET:c
a#2,RANGEDEL:z
a#2,SET:b
a#1,DEL:
----

iter is-bottommost-layer=true
first
next
next
----
a#inf,RANGEDEL:; Span() = a-z:{(#2,RANGEDEL)}
a#0,SET:c
.

iter is-bottommost-layer=true snapshots=3
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-z:{(#2,RANGEDEL)}
a#3,SET:c
a#0,SET:b
.

iter is-bottommost-layer=true snapshots=2
first
next
next
next
----
a#inf,RANGEDEL:; Span() = a-z:{(#2,RANGEDEL)}
a#3,SET:c
a#1,DEL:
.

define
a#4,SET:c
a#3,RANGEDEL:z
a#2,SET:b
a#1,DEL:
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-z:{(#3,RANGEDEL)}
a#4,SET:c
.

# Invalid keys are emitted under SETWITHDEL.

define
a#2,SET:b
a#1,INVALID:c
----

iter
first
----
err=invalid internal key kind: INVALID

define
a#3,SET:c
a#2,INVALID:c
a#1,SET:b
----

iter
first
----
err=invalid internal key kind: INVALID

# SINGLEDEL that meets a SETWITHDEL is transformed into a DEL.

define
a#3,SINGLEDEL:
a#2,SETWITHDEL:d
b#1,SET:c
----

iter
first
next
next
----
a#3,DEL:
b#1,SET:c
.

iter snapshots=2
first
next
next
----
a#3,DEL:
b#1,SET:c
.

iter snapshots=3
first
next
next
next
----
a#3,SINGLEDEL:
a#2,SETWITHDEL:d
b#1,SET:c
.

define
a#3,SETWITHDEL:3
a#2,SET:d
b#1,SET:c
----

iter print-missized-dels
first
next
next
----
a#3,SETWITHDEL:3
b#1,SET:c
.
missized-dels=0

iter snapshots=3
first
next
next
next
----
a#3,SETWITHDEL:3
a#2,SET:d
b#1,SET:c
.

# Test a DELSIZED whose encoded value matches the size of a deleted key. The
# DELSIZED's value should be removed, reflecting that the tombstone already
# dropped the key that it was expected to drop.

define
a#9,SET:foo
b#8,DELSIZED:varint(11)
b#5,SET:helloworld
c#2,SET:bar
----

iter print-missized-dels
first
next
next
----
a#9,SET:foo
b#8,DELSIZED:
c#2,SET:bar
missized-dels=0

# Test two DELSIZEDs meeting. The lower-sequenced number value should carry
# forward, at the higher sequence number. The first DELSIZED should be consider
# missized: It never found the key it was supposed to delete.

define
a#9,SET:foo
b#9,DELSIZED:varint(20)
b#8,DELSIZED:varint(10)
c#2,SET:bar
----

iter print-missized-dels
first
next
next
----
a#9,SET:foo
b#9,DELSIZED:varint(10)
c#2,SET:bar
missized-dels=1

# Test a DELSIZED whose encoded value is larger than the size of the deleted
# key. The DELSIZED should be replaced by an ordinary DEL with the same sequence
# number.

define
a#2,SET:foo
b#8,DELSIZED:varint(25)
b#3,SET:hello
c#9,SET:bar
----

iter print-missized-dels
first
next
next
----
a#2,SET:foo
b#8,DEL:
c#9,SET:bar
missized-dels=1

# Test two DELSIZED at the same user key, but with correctly sized deleted keys.

define
a#9,DELSIZED:varint(4)
a#8,SET:foo
a#8,DELSIZED:varint(6)
a#5,SET:hello
----

iter print-missized-dels
first
next
----
a#9,DELSIZED:
.
missized-dels=0

# Test the above scenario, except the second DELSIZED is missized. It should
# still count as missized.

define
a#9,DELSIZED:varint(4)
a#8,SET:foo
a#8,DELSIZED:varint(1)
a#5,SET:hello
----

iter print-missized-dels
first
next
----
a#9,DEL:
.
missized-dels=1

# Test the above scenario, except the second tombstone is a DEL. It should
# NOT count as missized.

define
a#9,DELSIZED:varint(4)
a#8,SET:foo
a#8,DEL:
a#5,SET:hello
----

iter print-missized-dels
first
next
----
a#9,DEL:
.
missized-dels=0

# Test various DELSIZEDs beneath live keys. SETS should be converted to
# SETWITHDELs when they meet a DELSIZED.

define
a#7,SET:foo
a#5,DELSIZED:varint(5)
b#4,SET:bar
b#2,DELSIZED:varint(4)
b#1,SET:bax
c#9,SET:coconut
c#8,DEL:del
c#5,DELSIZED:varint(2)
d#8,SET:dragonfruit
----

iter print-missized-dels
first
next
next
next
next
----
a#7,SETWITHDEL:foo
b#4,SETWITHDEL:bar
c#9,SETWITHDEL:coconut
d#8,SET:dragonfruit
.
missized-dels=0

# Test a DELSIZED meeting a MERGE. This counts as a missized DELâ€”The user can't
# know the value of the most recent MERGE since it's dependent on LSM state.

define
a#9,DELSIZED:varint(4)
a#8,MERGE:fo
a#7,MERGE:o
----

iter print-missized-dels
first
next
----
a#9,DEL:
.
missized-dels=1

# Test a DELSIZED that shadows a SINGLEDEL'd key.

define
a#4,DELSIZED:varint(4)
b#3,SINGLEDEL:
b#1,SET:val
----

iter
first
next
----
a#4,DELSIZED:varint(4)
.

# Repeat the above but with elision of tombstones.

iter elide-tombstones=t
first
----
.

# Test DELSIZED shadowing SINGLEDEL.

define
a#4,DELSIZED:varint(4)
a#2,SET:foo
b#3,SINGLEDEL:
b#1,SET:val
----

iter
first
next
----
a#4,DELSIZED:
.

# Repeat the above but with elision of tombstones.

iter elide-tombstones=t
first
----
.

# Test a very subtle sequence where a elision of tombstones is active, and a
# unskippable RANGEDEL sits between a DELSIZED and the key it was intended to
# delete. In previous versions of the code, the RANGEDEL was interleaved at its
# sequence number and "unskippable" breaking the skipping of keys within the
# snapshot stripe.

define
a#5,DELSIZED:varint(4)
a#4,RANGEDEL:d
a#3,SET:foo
----

iter elide-tombstones=t
first
next
----
.
.

# Try the same test as above, but with allowing sequence number zeroing as well.

iter elide-tombstones=t is-bottommost-layer=t
first
next
----
.
.

# Perform a variant of the above test but with a DEL key.

define
a#5,DEL:
a#4,RANGEDEL:d
a#3,SET:foo
----

iter elide-tombstones=t
first
next
----
.
.

# Perform a variant of the above test but with a SINGLEDEL key.

define
a#5,SINGLEDEL:
a#4,RANGEDEL:d
a#3,SET:foo
----

iter elide-tombstones=t
first
next
----
.
.
ineffectual-single-deletes: a

# Perform a few variants of the above but with a range del with a seqnum equal to
# keys. NB: When seqnums are equal, the order of keys with various kinds is:
#
# DeleteSized < RangeKey{Delete,Unset,Set} < SetWithDelete < RangeDelete < SingleDelete < Set < Delete
#
# NB: Range keys are interleaved always at the maximal sequence number, so the
# compaction iterator should always observe them first.

define
Span: a-z:{(#5,RANGEKEYDEL)}
a#6,SINGLEDEL:
a#5,SETWITHDEL:foo
a#5,RANGEDEL:z
----

# In the following case, the SINGLEDEL meets a SETWITHDEL, promoting the
# SINGLEDEL into a DEL.

iter
first
next
next
next
----
a#inf,RANGEKEYDEL:; Span() = a-z:{(#5,RANGEKEYDEL)}
a#inf,RANGEDEL:; Span() = a-z:{(#5,RANGEDEL)}
a#6,DEL:
.

# In this case, SINGLEDEL is elided (despite its transformation into a DEL) due
# to elide-tombstones=t.

iter elide-tombstones=t
first
next
next
----
.
.
.

define
a#6,SINGLEDEL:
a#5,RANGEDEL:d
a#5,SET:foo
----

# NB: In this case, in previous versions of the code, the RANGEDEL acted as an
# unintentional snapshot stripe change. This was a code artifact that was fixed
# when we began interleaving range deletions at the maximal sequence number
# using an interleaving iterator (like range keys are).

iter
first
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#5,RANGEDEL)}
.

iter elide-tombstones=t is-bottommost-layer=t
first
next
----
.
.

define
a#6,SINGLEDEL:
a#5,SET:foo
a#4,RANGEDEL:d
a#4,SET:bar
----

# In previous versions of the code, the SINGLEDEL invariant checking could not
# see past the RANGEDEL and see that the a#4,SET violates the invariant. This
# was a code artifact that has been improved when we began interleaving range
# deletes at the maximal sequence number

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#4,RANGEDEL)}
a#4,SET:bar
.
invariant-violation-single-deletes: a

define
a#6,SINGLEDEL:
a#5,SETWITHDEL:foo
a#5,RANGEDEL:d
----

# When the SINGLEDEL and SETWITHDEL meet, the SINGLEDEL is promoted into a DEL.

iter
first
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#5,RANGEDEL)}
a#6,DEL:

iter elide-tombstones=t
first
next
----
.
.

define
a#6,DELSIZED:varint(3)
a#5,RANGEDEL:d
a#5,SET:foo
----

iter
first
next
next
----
a#inf,RANGEDEL:; Span() = a-d:{(#5,RANGEDEL)}
a#6,DEL:
.

iter elide-tombstones=t
first
next
----
.
.

# Test a DELSIZED with a value that fails to decode.

define
a#5,DELSIZED:notavarint
a#4,SET:foo
----

iter
first
----
err=DELSIZED holds invalid value: 6e6f7461766172696e74

# Test a value-less DELSIZED.

define
a#5,DELSIZED:
a#4,SET:foo
a#3,SET:bar
----

iter print-missized-dels
first
next
----
a#5,DEL:
.
missized-dels=0

# Regression test for #3087.
#
# When a DELSIZED and a SINGLEDEL meet in a compaction, a DEL key should be
# emitted.

define
a#5,DELSIZED:
a#3,SINGLEDEL:
a#2,SET:foo
a#1,SET:bar
----

iter
first
next
----
a#5,DEL:
.

# When a MERGE and a DEL[SIZED] meet in a compaction, a SETWITHDEL key (NOT a
# SET) should be emitted. Otherwise, a sequence such as SINGLEDDEL, MERGE, DEL,
# SET could result in the SET re-appearing.

define
a#5,MERGE:foo
a#3,DEL:
----

iter
first
next
----
a#5,SETWITHDEL:foo[base]
.

define
a#4,SINGLEDEL:
a#3,MERGE:a3
a#2,SET:a2
b#6,SINGLEDEL:
b#5,SET:b5
b#4,SETWITHDEL:b4
----

iter
first
next
next
----
a#2,SET:a2
b#4,SETWITHDEL:b4
.
invariant-violation-single-deletes: a,b

# Add a test specifically for MissizedDeleteCallback
# This test creates a scenario where a DELSIZED tombstone's expected size
# doesn't match the actual size of the deleted entry.

define
a#8,DELSIZED:varint(25)
a#5,SET:hello
----

iter print-missized-dels print-missized-del-info
first
next
----
a#8,DEL:
.
missized-dels=1
missized-delete-info: a (elided=6, expected=25)

# Test a DELSIZED that never deletes a key (key doesn't exist)
define
a#8,DELSIZED:varint(10)
b#5,SET:hello
----

iter print-missized-dels print-missized-del-info
first
next
----
a#8,DELSIZED:varint(10)
b#5,SET:hello
missized-dels=0

# Test multiple missized DELSIZEDs in the same run
define
a#9,DELSIZED:varint(20)
a#8,SET:foo
b#7,DELSIZED:varint(15)
b#5,SET:bar
c#6,DELSIZED:varint(4)
c#3,SET:xyz
----

iter print-missized-dels print-missized-del-info
first
next
next
----
a#9,DEL:
b#7,DEL:
c#6,DELSIZED:
missized-dels=2
missized-delete-info: a (elided=4, expected=20); b (elided=4, expected=15)

# Test a delete sized that doesn't delete a key, because it meets another
# tombstone.

define
a#1,SET:hello
b#9,DELSIZED:varint(6)
b#4,DELSIZED:varint(6)
b#2,SET:world
----

iter print-missized-dels print-missized-del-info
first
next
next
----
a#1,SET:hello
b#9,DELSIZED:
.
missized-dels=1
missized-delete-info: b (elided=0, expected=6)
