# Test a scenario that should NOT result in defragmentation.

define
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
c-d:{(#4,RANGEKEYSET,@3,bananas)}
d-e:{(#4,RANGEKEYSET,@3,bananas) (#4,RANGEKEYSET,@1,pineapple)}
----

iter
first
next
next
last
prev
prev
----
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
c-d:{(#4,RANGEKEYSET,@3,bananas)}
d-e:{(#4,RANGEKEYSET,@3,bananas) (#4,RANGEKEYSET,@1,pineapple)}
d-e:{(#4,RANGEKEYSET,@3,bananas) (#4,RANGEKEYSET,@1,pineapple)}
c-d:{(#4,RANGEKEYSET,@3,bananas)}
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}

iter
first
next
next
next
last
prev
prev
prev
----
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
c-d:{(#4,RANGEKEYSET,@3,bananas)}
d-e:{(#4,RANGEKEYSET,@3,bananas) (#4,RANGEKEYSET,@1,pineapple)}
<nil>
d-e:{(#4,RANGEKEYSET,@3,bananas) (#4,RANGEKEYSET,@1,pineapple)}
c-d:{(#4,RANGEKEYSET,@3,bananas)}
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
<nil>

# Test a scenario that SHOULD result in internal defragmentation ([a,c) and
# [c,d) should be merged.

define
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
c-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
d-e:{(#1,RANGEKEYSET,@3,bananas)}
----

iter
first
next
next
----
a-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
d-e:{(#1,RANGEKEYSET,@3,bananas)}
<nil>

# Test defragmenting in both directions at seek keys.

define
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-h:{(#3,RANGEKEYSET,@3,bananas)}
h-p:{(#3,RANGEKEYSET,@3,bananas)}
p-t:{(#3,RANGEKEYSET,@3,bananas)}
----

iter
seekge b
prev
seekge b
next
seeklt d
next
seeklt d
prev
----
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
<nil>
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
<nil>

iter
seeklt d
next
prev
----
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}

# Test next-ing and prev-ing around seek keys.

define
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-h:{(#3,RANGEKEYSET,@3,bananas)}
h-p:{(#3,RANGEKEYSET,@3,bananas)}
p-t:{(#3,RANGEKEYSET,@3,bananas)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}
----

iter
seekge r
prev
next
next
----
f-t:{(#3,RANGEKEYSET,@3,bananas)}
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}

iter
seekge f
seekge h
seekge p
seekge t
seekge u
seekge v
seekge z
----
f-t:{(#3,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}
<nil>

iter
seeklt f
seeklt h
seeklt p
seeklt t
seeklt u
seeklt z
----
a-f:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
f-t:{(#3,RANGEKEYSET,@3,bananas)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}
t-z:{(#4,RANGEKEYSET,@2,oranges)}

# Test iteration with a reducer that collects keys across all spans that
# constitute a defragmented span. Abutting spans are always combined.

define
a-b:{(#3,RANGEDEL) (#2,RANGEDEL)}
b-c:{(#4,RANGEDEL) (#1,RANGEDEL)}
c-d:{(#5,RANGEDEL)}
e-f:{(#1,RANGEDEL)}
f-g:{(#2,RANGEDEL)}
----

iter equal=always reducer=collect
first
next
next
last
prev
prev
----
a-d:{(#5,RANGEDEL) (#4,RANGEDEL) (#3,RANGEDEL) (#2,RANGEDEL) (#1,RANGEDEL)}
e-g:{(#2,RANGEDEL) (#1,RANGEDEL)}
<nil>
e-g:{(#2,RANGEDEL) (#1,RANGEDEL)}
a-d:{(#5,RANGEDEL) (#4,RANGEDEL) (#3,RANGEDEL) (#2,RANGEDEL) (#1,RANGEDEL)}
<nil>

# Test defragmentation of non-empty (i.e. more than one value) fragments, while
# empty fragments are left untouched.

define
a-c:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
c-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
d-e:{}
e-f:{}
g-h:{(#1,RANGEKEYSET,@3,bananas)}
----

iter
first
next
next
next
next
----
a-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
d-e:{}
e-f:{}
g-h:{(#1,RANGEKEYSET,@3,bananas)}
<nil>

iter
last
prev
prev
prev
prev
----
g-h:{(#1,RANGEKEYSET,@3,bananas)}
e-f:{}
d-e:{}
a-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
<nil>

iter
seekge d
next
prev
seekge e
next
prev
prev
prev
----
d-e:{}
e-f:{}
d-e:{}
e-f:{}
g-h:{(#1,RANGEKEYSET,@3,bananas)}
e-f:{}
d-e:{}
a-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}

iter
seeklt e
next
prev
seeklt f
next
prev
prev
prev
----
d-e:{}
e-f:{}
d-e:{}
e-f:{}
g-h:{(#1,RANGEKEYSET,@3,bananas)}
e-f:{}
d-e:{}
a-d:{(#3,RANGEKEYUNSET,@5) (#2,RANGEKEYSET,@5,apples) (#1,RANGEKEYSET,@3,bananas)}
