define
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
----

iter
seek-ge a
seek-ge b
seek-ge c
seek-ge d
seek-lt a
seek-lt b
seek-lt c
seek-lt d
----
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
.
.
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}

iter
first
next
prev
prev
next
next
next
prev
next
next
prev
----
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
a-b:{(#2,SET) (#1,SET)}
.
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
.
c-d:{(#2,SET) (#1,SET)}

# a-b:{(#2,SET) (#1,SET)}
# b-c:{(#2,SET) (#1,SET)}
# c-d:{(#2,SET) (#1,SET)}

iter
set-bounds x z
first
last
seek-ge x
seek-lt z
----
.
.
.
.
.

iter
set-bounds cap cat
first
last
seek-ge c
next
seek-lt cat
prev
----
.
c-d:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
.
c-d:{(#2,SET) (#1,SET)}
.

iter
set-bounds a cc
first
next
next
next
----
.
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
.

iter
set-bounds a c
first
next
next
----
.
a-b:{(#2,SET) (#1,SET)}
b-c:{(#2,SET) (#1,SET)}
.

iter
set-bounds b cc
first
next
next
----
.
b-c:{(#2,SET) (#1,SET)}
c-d:{(#2,SET) (#1,SET)}
.

# Test behavior around bounds. Previously, there existed a bug where bounds
# the iterator's index was not set during absolute positioning calls that return
# zero elements. This allowed releative positioning methods to surface
# out-of-bounds values because only the bound in the direction of iteration is
# checked.

iter
last
set-bounds a a
first
prev
prev
----
c-d:{(#2,SET) (#1,SET)}
.
.
.
.

iter
first
set-bounds d d
last
next
next
----
a-b:{(#2,SET) (#1,SET)}
.
.
.
.
