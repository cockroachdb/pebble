// Code generated by genprops; DO NOT EDIT.
package sstable

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"iter"
	"maps"
	"slices"
	"strings"

	"github.com/cockroachdb/pebble/internal/intern"
)

// load populates *Properties from an iterator and records which fields were
// present using the bitâ€‘vector.
func (p *Properties) load(i iter.Seq2[[]byte, []byte]) error {
	p.Loaded = 0
	for k, v := range i {
		switch string(k) {
		case "rocksdb.num.entries":
			p.Loaded |= 1 << _bit_NumEntries
			n, _ := binary.Uvarint(v)
			p.NumEntries = n
		case "rocksdb.raw.key.size":
			p.Loaded |= 1 << _bit_RawKeySize
			n, _ := binary.Uvarint(v)
			p.RawKeySize = n
		case "rocksdb.raw.value.size":
			p.Loaded |= 1 << _bit_RawValueSize
			n, _ := binary.Uvarint(v)
			p.RawValueSize = n
		case "pebble.raw.point-tombstone.key.size":
			p.Loaded |= 1 << _bit_RawPointTombstoneKeySize
			n, _ := binary.Uvarint(v)
			p.RawPointTombstoneKeySize = n
		case "pebble.raw.point-tombstone.value.size":
			p.Loaded |= 1 << _bit_RawPointTombstoneValueSize
			n, _ := binary.Uvarint(v)
			p.RawPointTombstoneValueSize = n
		case "pebble.num.deletions.sized":
			p.Loaded |= 1 << _bit_NumSizedDeletions
			n, _ := binary.Uvarint(v)
			p.NumSizedDeletions = n
		case "rocksdb.deleted.keys":
			p.Loaded |= 1 << _bit_NumDeletions
			n, _ := binary.Uvarint(v)
			p.NumDeletions = n
		case "rocksdb.num.range-deletions":
			p.Loaded |= 1 << _bit_NumRangeDeletions
			n, _ := binary.Uvarint(v)
			p.NumRangeDeletions = n
		case "pebble.num.range-key-dels":
			p.Loaded |= 1 << _bit_NumRangeKeyDels
			n, _ := binary.Uvarint(v)
			p.NumRangeKeyDels = n
		case "pebble.num.range-key-sets":
			p.Loaded |= 1 << _bit_NumRangeKeySets
			n, _ := binary.Uvarint(v)
			p.NumRangeKeySets = n
		case "pebble.value-blocks.size":
			p.Loaded |= 1 << _bit_ValueBlocksSize
			n, _ := binary.Uvarint(v)
			p.ValueBlocksSize = n
		case "rocksdb.num.data.blocks":
			p.Loaded |= 1 << _bit_NumDataBlocks
			n, _ := binary.Uvarint(v)
			p.NumDataBlocks = n
		case "pebble.num.tombstone-dense-blocks":
			p.Loaded |= 1 << _bit_NumTombstoneDenseBlocks
			n, _ := binary.Uvarint(v)
			p.NumTombstoneDenseBlocks = n
		case "rocksdb.comparator":
			p.Loaded |= 1 << _bit_ComparerName
			p.ComparerName = intern.Bytes(v)
		case "rocksdb.data.size":
			p.Loaded |= 1 << _bit_DataSize
			n, _ := binary.Uvarint(v)
			p.DataSize = n
		case "rocksdb.filter.policy":
			p.Loaded |= 1 << _bit_FilterPolicyName
			p.FilterPolicyName = intern.Bytes(v)
		case "rocksdb.filter.size":
			p.Loaded |= 1 << _bit_FilterSize
			n, _ := binary.Uvarint(v)
			p.FilterSize = n
		case "rocksdb.index.partitions":
			p.Loaded |= 1 << _bit_IndexPartitions
			n, _ := binary.Uvarint(v)
			p.IndexPartitions = n
		case "rocksdb.index.size":
			p.Loaded |= 1 << _bit_IndexSize
			n, _ := binary.Uvarint(v)
			p.IndexSize = n
		case "rocksdb.block.based.table.index.type":
			p.Loaded |= 1 << _bit_IndexType
			p.IndexType = binary.LittleEndian.Uint32(v)
		case "pebble.obsolete.is_strict":
			p.Loaded |= 1 << _bit_IsStrictObsolete
			p.IsStrictObsolete = len(v) == 1 && v[0] == '1'
		case "pebble.colblk.schema":
			p.Loaded |= 1 << _bit_KeySchemaName
			p.KeySchemaName = intern.Bytes(v)
		case "rocksdb.merge.operator":
			p.Loaded |= 1 << _bit_MergerName
			p.MergerName = intern.Bytes(v)
		case "rocksdb.merge.operands":
			p.Loaded |= 1 << _bit_NumMergeOperands
			n, _ := binary.Uvarint(v)
			p.NumMergeOperands = n
		case "pebble.num.range-key-unsets":
			p.Loaded |= 1 << _bit_NumRangeKeyUnsets
			n, _ := binary.Uvarint(v)
			p.NumRangeKeyUnsets = n
		case "pebble.num.value-blocks":
			p.Loaded |= 1 << _bit_NumValueBlocks
			n, _ := binary.Uvarint(v)
			p.NumValueBlocks = n
		case "pebble.num.values.in.value-blocks":
			p.Loaded |= 1 << _bit_NumValuesInValueBlocks
			n, _ := binary.Uvarint(v)
			p.NumValuesInValueBlocks = n
		case "pebble.num.values.in.blob-files":
			p.Loaded |= 1 << _bit_NumValuesInBlobFiles
			n, _ := binary.Uvarint(v)
			p.NumValuesInBlobFiles = n
		case "rocksdb.property.collectors":
			p.Loaded |= 1 << _bit_PropertyCollectorNames
			p.PropertyCollectorNames = intern.Bytes(v)
		case "pebble.raw.range-key.key.size":
			p.Loaded |= 1 << _bit_RawRangeKeyKeySize
			n, _ := binary.Uvarint(v)
			p.RawRangeKeyKeySize = n
		case "pebble.raw.range-key.value.size":
			p.Loaded |= 1 << _bit_RawRangeKeyValueSize
			n, _ := binary.Uvarint(v)
			p.RawRangeKeyValueSize = n
		case "pebble.num.snapshot-pinned-keys":
			p.Loaded |= 1 << _bit_SnapshotPinnedKeys
			n, _ := binary.Uvarint(v)
			p.SnapshotPinnedKeys = n
		case "pebble.raw.snapshot-pinned-keys.size":
			p.Loaded |= 1 << _bit_SnapshotPinnedKeySize
			n, _ := binary.Uvarint(v)
			p.SnapshotPinnedKeySize = n
		case "pebble.raw.snapshot-pinned-values.size":
			p.Loaded |= 1 << _bit_SnapshotPinnedValueSize
			n, _ := binary.Uvarint(v)
			p.SnapshotPinnedValueSize = n
		case "rocksdb.top-level.index.size":
			p.Loaded |= 1 << _bit_TopLevelIndexSize
			n, _ := binary.Uvarint(v)
			p.TopLevelIndexSize = n
		case "rocksdb.compression":
			p.Loaded |= 1 << _bit_CompressionName
			p.CompressionName = string(v)
		case "pebble.compression_stats":
			p.Loaded |= 1 << _bit_CompressionStats
			p.CompressionStats = string(v)
		case "pebble.value-separation.kind":
			p.Loaded |= 1 << _bit_ValueSeparationKind
			p.ValueSeparationKind = v[0]
		case "pebble.value-separation.min-size":
			p.Loaded |= 1 << _bit_ValueSeparationMinSize
			n, _ := binary.Uvarint(v)
			p.ValueSeparationMinSize = n
		default:
			if _, denied := ignoredInternalProperties[string(k)]; !denied {
				if p.UserProperties == nil {
					p.UserProperties = make(map[string]string)
				}
				p.UserProperties[intern.Bytes(k)] = string(v)
			}
		}
	}
	return nil
}

// encodeAll returns a map of property keys and encoded values.
func (p *Properties) encodeAll() map[string][]byte {
	m := make(map[string][]byte, _numPropBits+len(p.UserProperties))
	var allocBuf []byte
	alloc := func(n int) []byte {
		if len(allocBuf) < n {
			allocBuf = make([]byte, n+512)
		}
		res := allocBuf[:n]
		allocBuf = allocBuf[n:]
		return res
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumEntries)
		val = val[:n]
		m["rocksdb.num.entries"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawKeySize)
		val = val[:n]
		m["rocksdb.raw.key.size"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawValueSize)
		val = val[:n]
		m["rocksdb.raw.value.size"] = val
	}
	if p.RawPointTombstoneKeySize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawPointTombstoneKeySize)
		val = val[:n]
		m["pebble.raw.point-tombstone.key.size"] = val
	}
	if p.RawPointTombstoneValueSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawPointTombstoneValueSize)
		val = val[:n]
		m["pebble.raw.point-tombstone.value.size"] = val
	}
	if p.NumSizedDeletions != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumSizedDeletions)
		val = val[:n]
		m["pebble.num.deletions.sized"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumDeletions)
		val = val[:n]
		m["rocksdb.deleted.keys"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumRangeDeletions)
		val = val[:n]
		m["rocksdb.num.range-deletions"] = val
	}
	if p.NumRangeKeyDels != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumRangeKeyDels)
		val = val[:n]
		m["pebble.num.range-key-dels"] = val
	}
	if p.NumRangeKeySets != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumRangeKeySets)
		val = val[:n]
		m["pebble.num.range-key-sets"] = val
	}
	if p.ValueBlocksSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.ValueBlocksSize)
		val = val[:n]
		m["pebble.value-blocks.size"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumDataBlocks)
		val = val[:n]
		m["rocksdb.num.data.blocks"] = val
	}
	if p.NumTombstoneDenseBlocks != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumTombstoneDenseBlocks)
		val = val[:n]
		m["pebble.num.tombstone-dense-blocks"] = val
	}
	if true {
		val := alloc(len(p.ComparerName))
		copy(val, p.ComparerName)
		m["rocksdb.comparator"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.DataSize)
		val = val[:n]
		m["rocksdb.data.size"] = val
	}
	if p.FilterPolicyName != "" {
		val := alloc(len(p.FilterPolicyName))
		copy(val, p.FilterPolicyName)
		m["rocksdb.filter.policy"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.FilterSize)
		val = val[:n]
		m["rocksdb.filter.size"] = val
	}
	if p.IndexPartitions != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.IndexPartitions)
		val = val[:n]
		m["rocksdb.index.partitions"] = val
	}
	if p.IndexSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.IndexSize)
		val = val[:n]
		m["rocksdb.index.size"] = val
	}
	if true {
		val := alloc(4)
		binary.LittleEndian.PutUint32(val, p.IndexType)
		m["rocksdb.block.based.table.index.type"] = val
	}
	if p.IsStrictObsolete != false {
		val := alloc(1)
		val[0] = '0'
		if p.IsStrictObsolete {
			val[0] = '1'
		}
		m["pebble.obsolete.is_strict"] = val
	}
	if p.KeySchemaName != "" {
		val := alloc(len(p.KeySchemaName))
		copy(val, p.KeySchemaName)
		m["pebble.colblk.schema"] = val
	}
	if true {
		val := alloc(len(p.MergerName))
		copy(val, p.MergerName)
		m["rocksdb.merge.operator"] = val
	}
	if true {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumMergeOperands)
		val = val[:n]
		m["rocksdb.merge.operands"] = val
	}
	if p.NumRangeKeyUnsets != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumRangeKeyUnsets)
		val = val[:n]
		m["pebble.num.range-key-unsets"] = val
	}
	if p.NumValueBlocks != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumValueBlocks)
		val = val[:n]
		m["pebble.num.value-blocks"] = val
	}
	if p.NumValuesInValueBlocks != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumValuesInValueBlocks)
		val = val[:n]
		m["pebble.num.values.in.value-blocks"] = val
	}
	if p.NumValuesInBlobFiles != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.NumValuesInBlobFiles)
		val = val[:n]
		m["pebble.num.values.in.blob-files"] = val
	}
	if true {
		val := alloc(len(p.PropertyCollectorNames))
		copy(val, p.PropertyCollectorNames)
		m["rocksdb.property.collectors"] = val
	}
	if p.RawRangeKeyKeySize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawRangeKeyKeySize)
		val = val[:n]
		m["pebble.raw.range-key.key.size"] = val
	}
	if p.RawRangeKeyValueSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.RawRangeKeyValueSize)
		val = val[:n]
		m["pebble.raw.range-key.value.size"] = val
	}
	if p.SnapshotPinnedKeys != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.SnapshotPinnedKeys)
		val = val[:n]
		m["pebble.num.snapshot-pinned-keys"] = val
	}
	if p.SnapshotPinnedKeySize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.SnapshotPinnedKeySize)
		val = val[:n]
		m["pebble.raw.snapshot-pinned-keys.size"] = val
	}
	if p.SnapshotPinnedValueSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.SnapshotPinnedValueSize)
		val = val[:n]
		m["pebble.raw.snapshot-pinned-values.size"] = val
	}
	if p.TopLevelIndexSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.TopLevelIndexSize)
		val = val[:n]
		m["rocksdb.top-level.index.size"] = val
	}
	if p.CompressionName != "" {
		val := alloc(len(p.CompressionName))
		copy(val, p.CompressionName)
		m["rocksdb.compression"] = val
	}
	if p.CompressionStats != "" {
		val := alloc(len(p.CompressionStats))
		copy(val, p.CompressionStats)
		m["pebble.compression_stats"] = val
	}
	if p.ValueSeparationKind != 0 {
		val := alloc(1)
		val[0] = p.ValueSeparationKind
		m["pebble.value-separation.kind"] = val
	}
	if p.ValueSeparationMinSize != 0 {
		val := alloc(10)
		n := binary.PutUvarint(val, p.ValueSeparationMinSize)
		val = val[:n]
		m["pebble.value-separation.min-size"] = val
	}
	return m
}

// isLoaded returns true if the bit corresponding to field bit is set.
func (p *Properties) isLoaded(bit int) bool { return p.Loaded&(1<<bit) != 0 }

// String writes a humanâ€‘readable representation of Properties, matching the
// previous reflectionâ€‘based output.
func (p *Properties) String() string {
	var buf bytes.Buffer
	if p.NumEntries != 0 || p.isLoaded(_bit_NumEntries) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.num.entries", p.NumEntries)
	}
	if p.RawKeySize != 0 || p.isLoaded(_bit_RawKeySize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.raw.key.size", p.RawKeySize)
	}
	if p.RawValueSize != 0 || p.isLoaded(_bit_RawValueSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.raw.value.size", p.RawValueSize)
	}
	if p.RawPointTombstoneKeySize != 0 || p.isLoaded(_bit_RawPointTombstoneKeySize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.point-tombstone.key.size", p.RawPointTombstoneKeySize)
	}
	if p.RawPointTombstoneValueSize != 0 || p.isLoaded(_bit_RawPointTombstoneValueSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.point-tombstone.value.size", p.RawPointTombstoneValueSize)
	}
	if p.NumSizedDeletions != 0 || p.isLoaded(_bit_NumSizedDeletions) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.deletions.sized", p.NumSizedDeletions)
	}
	if p.NumDeletions != 0 || p.isLoaded(_bit_NumDeletions) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.deleted.keys", p.NumDeletions)
	}
	if p.NumRangeDeletions != 0 || p.isLoaded(_bit_NumRangeDeletions) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.num.range-deletions", p.NumRangeDeletions)
	}
	if p.NumRangeKeyDels != 0 || p.isLoaded(_bit_NumRangeKeyDels) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.range-key-dels", p.NumRangeKeyDels)
	}
	if p.NumRangeKeySets != 0 || p.isLoaded(_bit_NumRangeKeySets) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.range-key-sets", p.NumRangeKeySets)
	}
	if p.ValueBlocksSize != 0 || p.isLoaded(_bit_ValueBlocksSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.value-blocks.size", p.ValueBlocksSize)
	}
	if p.NumDataBlocks != 0 || p.isLoaded(_bit_NumDataBlocks) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.num.data.blocks", p.NumDataBlocks)
	}
	if p.NumTombstoneDenseBlocks != 0 || p.isLoaded(_bit_NumTombstoneDenseBlocks) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.tombstone-dense-blocks", p.NumTombstoneDenseBlocks)
	}
	if p.ComparerName != "" || p.isLoaded(_bit_ComparerName) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.comparator", p.ComparerName)
	}
	if p.DataSize != 0 || p.isLoaded(_bit_DataSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.data.size", p.DataSize)
	}
	if p.FilterPolicyName != "" || p.isLoaded(_bit_FilterPolicyName) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.filter.policy", p.FilterPolicyName)
	}
	if p.FilterSize != 0 || p.isLoaded(_bit_FilterSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.filter.size", p.FilterSize)
	}
	if p.IndexPartitions != 0 || p.isLoaded(_bit_IndexPartitions) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.index.partitions", p.IndexPartitions)
	}
	if p.IndexSize != 0 || p.isLoaded(_bit_IndexSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.index.size", p.IndexSize)
	}
	if p.IndexType != 0 || p.isLoaded(_bit_IndexType) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.block.based.table.index.type", p.IndexType)
	}
	if p.IsStrictObsolete != false || p.isLoaded(_bit_IsStrictObsolete) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.obsolete.is_strict", p.IsStrictObsolete)
	}
	if p.KeySchemaName != "" || p.isLoaded(_bit_KeySchemaName) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.colblk.schema", p.KeySchemaName)
	}
	if p.MergerName != "" || p.isLoaded(_bit_MergerName) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.merge.operator", p.MergerName)
	}
	if p.NumMergeOperands != 0 || p.isLoaded(_bit_NumMergeOperands) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.merge.operands", p.NumMergeOperands)
	}
	if p.NumRangeKeyUnsets != 0 || p.isLoaded(_bit_NumRangeKeyUnsets) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.range-key-unsets", p.NumRangeKeyUnsets)
	}
	if p.NumValueBlocks != 0 || p.isLoaded(_bit_NumValueBlocks) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.value-blocks", p.NumValueBlocks)
	}
	if p.NumValuesInValueBlocks != 0 || p.isLoaded(_bit_NumValuesInValueBlocks) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.values.in.value-blocks", p.NumValuesInValueBlocks)
	}
	if p.NumValuesInBlobFiles != 0 || p.isLoaded(_bit_NumValuesInBlobFiles) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.values.in.blob-files", p.NumValuesInBlobFiles)
	}
	if p.PropertyCollectorNames != "" || p.isLoaded(_bit_PropertyCollectorNames) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.property.collectors", p.PropertyCollectorNames)
	}
	if p.RawRangeKeyKeySize != 0 || p.isLoaded(_bit_RawRangeKeyKeySize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.range-key.key.size", p.RawRangeKeyKeySize)
	}
	if p.RawRangeKeyValueSize != 0 || p.isLoaded(_bit_RawRangeKeyValueSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.range-key.value.size", p.RawRangeKeyValueSize)
	}
	if p.SnapshotPinnedKeys != 0 || p.isLoaded(_bit_SnapshotPinnedKeys) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.num.snapshot-pinned-keys", p.SnapshotPinnedKeys)
	}
	if p.SnapshotPinnedKeySize != 0 || p.isLoaded(_bit_SnapshotPinnedKeySize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.snapshot-pinned-keys.size", p.SnapshotPinnedKeySize)
	}
	if p.SnapshotPinnedValueSize != 0 || p.isLoaded(_bit_SnapshotPinnedValueSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.raw.snapshot-pinned-values.size", p.SnapshotPinnedValueSize)
	}
	if p.TopLevelIndexSize != 0 || p.isLoaded(_bit_TopLevelIndexSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.top-level.index.size", p.TopLevelIndexSize)
	}
	if p.CompressionName != "" || p.isLoaded(_bit_CompressionName) {
		fmt.Fprintf(&buf, "%s: %v\n", "rocksdb.compression", p.CompressionName)
	}
	if p.CompressionStats != "" || p.isLoaded(_bit_CompressionStats) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.compression_stats", p.CompressionStats)
	}
	if p.ValueSeparationKind != 0 || p.isLoaded(_bit_ValueSeparationKind) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.value-separation.kind", p.ValueSeparationKind)
	}
	if p.ValueSeparationMinSize != 0 || p.isLoaded(_bit_ValueSeparationMinSize) {
		fmt.Fprintf(&buf, "%s: %v\n", "pebble.value-separation.min-size", p.ValueSeparationMinSize)
	}
	if len(p.UserProperties) > 0 {
		// Print the user properties in alphabetical order.
		for _, k := range slices.Sorted(maps.Keys(p.UserProperties)) {
			v := p.UserProperties[k]
			if strings.IndexFunc(v, func(r rune) bool { return r < ' ' || r > '~' }) != -1 {
				fmt.Fprintf(&buf, "%s: hex:%x\n", k, v)
			} else {
				fmt.Fprintf(&buf, "%s: %s\n", k, v)
			}
		}
	}
	return buf.String()
}

// Bit positions for property field.
const (
	_bit_NumEntries                 = 0
	_bit_RawKeySize                 = 1
	_bit_RawValueSize               = 2
	_bit_RawPointTombstoneKeySize   = 3
	_bit_RawPointTombstoneValueSize = 4
	_bit_NumSizedDeletions          = 5
	_bit_NumDeletions               = 6
	_bit_NumRangeDeletions          = 7
	_bit_NumRangeKeyDels            = 8
	_bit_NumRangeKeySets            = 9
	_bit_ValueBlocksSize            = 10
	_bit_NumDataBlocks              = 11
	_bit_NumTombstoneDenseBlocks    = 12
	_bit_ComparerName               = 13
	_bit_DataSize                   = 14
	_bit_FilterPolicyName           = 15
	_bit_FilterSize                 = 16
	_bit_IndexPartitions            = 17
	_bit_IndexSize                  = 18
	_bit_IndexType                  = 19
	_bit_IsStrictObsolete           = 20
	_bit_KeySchemaName              = 21
	_bit_MergerName                 = 22
	_bit_NumMergeOperands           = 23
	_bit_NumRangeKeyUnsets          = 24
	_bit_NumValueBlocks             = 25
	_bit_NumValuesInValueBlocks     = 26
	_bit_NumValuesInBlobFiles       = 27
	_bit_PropertyCollectorNames     = 28
	_bit_RawRangeKeyKeySize         = 29
	_bit_RawRangeKeyValueSize       = 30
	_bit_SnapshotPinnedKeys         = 31
	_bit_SnapshotPinnedKeySize      = 32
	_bit_SnapshotPinnedValueSize    = 33
	_bit_TopLevelIndexSize          = 34
	_bit_CompressionName            = 35
	_bit_CompressionStats           = 36
	_bit_ValueSeparationKind        = 37
	_bit_ValueSeparationMinSize     = 38
	_numPropBits                    = 39
)
