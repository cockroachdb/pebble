// Copyright 2025 The LevelDB-Go and Pebble Authors. All rights reserved. Use
// of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

// Field represents a struct field tagged with `prop:"..."`.
type Field struct {
	Name        string // Go identifier
	Tag         string // tag value
	Kind        string // bool | uint32 | uint64 | string
	EncodeEmpty bool   // whether to encode empty a zero value
	Intern      bool   // whether to intern the string value
}

// Template for sstable/properties_gen.go.
const tmpl = `// Code generated by genprops; DO NOT EDIT.
package sstable

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"iter"
	"maps"
	"slices"
	"strings"

  "github.com/cockroachdb/pebble/internal/intern"
)

// load populates *Properties from an iterator and records which fields were
// present using the bit‑vector.
func (p *Properties) load(i iter.Seq2[[]byte, []byte]) error {
  p.Loaded = 0
  for k, v := range i {
    switch string(k) {
{{- range .Fields }}
    case "{{ .Tag }}":
      p.Loaded |= 1 << _bit_{{ .Name }}
  {{- if eq .Kind "bool" }}
      p.{{ .Name }} = len(v) == 1 && v[0] == '1'
  {{- else if eq .Kind "uint32" }}
      p.{{ .Name }} = binary.LittleEndian.Uint32(v)
  {{- else if eq .Kind "uint64" }}
      n, _ := binary.Uvarint(v)
      p.{{ .Name }} = n
  {{- else if eq .Kind "string" }}
    {{- if .Intern }}
      p.{{ .Name }} = intern.Bytes(v)
    {{- else }}
      p.{{ .Name }} = string(v)
    {{- end }}
  {{- end }}
{{- end }}
    default:
      if _, denied := ignoredInternalProperties[string(k)]; !denied {
        if p.UserProperties == nil {
          p.UserProperties = make(map[string]string)
        }
        p.UserProperties[intern.Bytes(k)] = string(v)
      }
    }
  }
  return nil
}

// encodeAll returns a map of property keys and encoded values.
func (p *Properties) encodeAll() map[string][]byte {
  m := make(map[string][]byte, _numPropBits+len(p.UserProperties))
  var allocBuf []byte
  alloc := func(n int) []byte {
    if len(allocBuf) < n {
      allocBuf = make([]byte, n + 512)
    }
    res := allocBuf[:n]
    allocBuf = allocBuf[n:]
    return res
  }
  
{{- range .Fields }}
{{- if .EncodeEmpty }}
  if true {
{{- else }}
  if p.{{ .Name }} != {{ zeroVal .Kind }} {
{{- end }}
{{- if eq .Kind "bool" }}
    val := alloc(1)
    val[0] = '0'
    if p.{{ .Name }} {
      val[0] = '1'
    }
{{- else if eq .Kind "uint32" }}
    val := alloc(4)
    binary.LittleEndian.PutUint32(val, p.{{ .Name }})
{{- else if eq .Kind "uint64" }}
    val := alloc(10)
    n := binary.PutUvarint(val, p.{{ .Name }})
    val = val[:n]
{{- else if eq .Kind "string" }}
    val := alloc(len(p.{{ .Name }}))
    copy(val, p.{{ .Name }})
{{- end }}
    m["{{ .Tag }}"] = val
  }
{{- end }}
  return m
}

// isLoaded returns true if the bit corresponding to field bit is set.
func (p *Properties) isLoaded(bit int) bool { return p.Loaded&(1<<bit) != 0 }

// String writes a human‑readable representation of Properties, matching the
// previous reflection‑based output.
func (p *Properties) String() string {
  var buf bytes.Buffer
{{- range .Fields }}
  if p.{{ .Name }} != {{ zeroVal .Kind }} || p.isLoaded(_bit_{{ .Name }}) {
    fmt.Fprintf(&buf, "%s: %v\n", "{{ .Tag }}", p.{{ .Name }})
  }
{{- end }}
  if len(p.UserProperties) > 0 {
    // Print the user properties in alphabetical order.
    for _, k := range slices.Sorted(maps.Keys(p.UserProperties)) {
      v := p.UserProperties[k]
      if strings.IndexFunc(v, func(r rune) bool { return r < ' ' || r > '~' }) != -1 {
        fmt.Fprintf(&buf, "%s: hex:%x\n", k, v)
      } else {
        fmt.Fprintf(&buf, "%s: %s\n", k, v)
      }
    }
  }
  return buf.String()
}

// Bit positions for property field.
const (
{{- range $i, $f := .Fields }}
  _bit_{{$f.Name}} = {{$i}}
{{- end }}
  _numPropBits = {{ len .Fields }}
)
` // end template

// zeroVal returns a literal zero value string for the given kind.
func zeroVal(kind string) string {
	switch kind {
	case "bool":
		return "false"
	case "uint32", "uint64":
		return "0"
	case "string":
		return `""`
	default:
		return "nil"
	}
}

func main() {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedSyntax | packages.NeedDeps |
			packages.NeedTypesInfo | packages.NeedFiles | packages.NeedName,
	}

	pkgs, err := packages.Load(cfg, "github.com/cockroachdb/pebble/sstable")
	if err != nil {
		log.Fatalf("loading packages: %v", err)
	}

	var fields []Field
	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			for _, decl := range file.Decls {
				gd, ok := decl.(*ast.GenDecl)
				if !ok || gd.Tok != token.TYPE {
					continue
				}
				for _, spec := range gd.Specs {
					ts := spec.(*ast.TypeSpec)
					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}
					qname := pkg.Types.Path() + "." + ts.Name.Name
					if qname != "github.com/cockroachdb/pebble/sstable.Properties" {
						continue
					}
					for _, f := range st.Fields.List {
						if f.Tag == nil || len(f.Names) == 0 {
							continue
						}
						tags := reflect.StructTag(strings.Trim(f.Tag.Value, "`"))
						tag := tags.Get("prop")
						if tag == "" {
							continue
						}
						options := strings.Split(tags.Get("options"), ",")
						name := f.Names[0].Name
						typ := pkg.TypesInfo.Types[f.Type].Type.String()
						var kind string
						switch typ {
						case "bool":
							kind = "bool"
						case "uint32":
							kind = "uint32"
						case "uint64":
							kind = "uint64"
						case "string":
							kind = "string"
						default:
							log.Fatalf("unsupported property type %s", typ)
						}
						// We always encode some properties, even if they are zero.
						encodeEmpty := slices.Contains(options, "encodeempty")
						intern := slices.Contains(options, "intern")
						fields = append(fields, Field{Name: name, Tag: tag, Kind: kind, EncodeEmpty: encodeEmpty, Intern: intern})
					}
				}
			}
		}
	}

	if len(fields) > 64 {
		log.Fatalf("too many prop fields (%d), exceeds 64‑bit bitfield", len(fields))
	}
	var sstableDir string
	for _, pkg := range pkgs {
		if pkg.PkgPath == "github.com/cockroachdb/pebble/sstable" {
			sstableDir = filepath.Dir(pkg.GoFiles[0])
			break
		}
	}
	if sstableDir == "" {
		log.Fatalf("sstable package not found")
	}
	outputFile := filepath.Join(sstableDir, "properties_gen.go")

	t := template.Must(template.New("gen").Funcs(template.FuncMap{
		"zeroVal": zeroVal,
	}).Parse(tmpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, map[string]any{"Fields": fields}); err != nil {
		log.Fatalf("executing template: %v", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		_ = os.WriteFile(outputFile, buf.Bytes(), 0o644)
		log.Fatalf("formatting source: %v\n", err)
	}

	if err := os.WriteFile(outputFile, src, 0o644); err != nil {
		log.Fatalf("writing generated file: %v", err)
	}
}
