build
a#1,SET:A
b#2,SET:B
c#3,SET:C
d#4,SET:D
----

iter
first
next
next
next
next
----
first: <a:1>:A
 next: <b:2>:B
 next: <c:3>:C
 next: <d:4>:D
 next: .

iter
seek-ge a
next
next
next
next
----
seek-ge a: <a:1>:A
     next: <b:2>:B
     next: <c:3>:C
     next: <d:4>:D
     next: .

iter
seek-ge b
next
next
next
----
seek-ge b: <b:2>:B
     next: <c:3>:C
     next: <d:4>:D
     next: .

iter
seek-ge c
next
next
----
seek-ge c: <c:3>:C
     next: <d:4>:D
     next: .

iter
seek-ge d
next
----
seek-ge d: <d:4>:D
     next: .

iter
seek-ge e
----
seek-ge e: .

iter
seek-ge d
seek-ge z
----
seek-ge d: <d:4>:D
seek-ge z: .

iter
seek-ge b
seek-ge c
seek-ge d
seek-ge e
----
seek-ge b: <b:2>:B
seek-ge c: <c:3>:C
seek-ge d: <d:4>:D
seek-ge e: .

iter
last
prev
prev
prev
prev
----
last: <d:4>:D
prev: <c:3>:C
prev: <b:2>:B
prev: <a:1>:A
prev: .

iter
seek-lt e
prev
prev
prev
prev
----
seek-lt e: <d:4>:D
     prev: <c:3>:C
     prev: <b:2>:B
     prev: <a:1>:A
     prev: .

iter
seek-lt d
prev
prev
prev
----
seek-lt d: <c:3>:C
     prev: <b:2>:B
     prev: <a:1>:A
     prev: .

iter
seek-lt c
prev
prev
----
seek-lt c: <b:2>:B
     prev: <a:1>:A
     prev: .

iter
seek-lt b
prev
----
seek-lt b: <a:1>:A
     prev: .

iter
seek-lt a
----
seek-lt a: .

iter
seek-lt d
seek-lt c
seek-lt b
seek-lt a
----
seek-lt d: <c:3>:C
seek-lt c: <b:2>:B
seek-lt b: <a:1>:A
seek-lt a: .

iter globalSeqNum=1
first
next
next
next
next
----
first: <a:1>:A
 next: <b:1>:B
 next: <c:1>:C
 next: <d:1>:D
 next: .

iter globalSeqNum=10
first
next
next
next
next
----
first: <a:10>:A
 next: <b:10>:B
 next: <c:10>:C
 next: <d:10>:D
 next: .

iter globalSeqNum=0
seek-lt x
----
seek-lt x: <d:4>:D

get
b
a
f
d
c
----
B
A
<err: pebble: not found>
D
C

# Verify that clearing the bounds on an iterator also clears
# previously set block{Lower,Upper}.

iter
seek-ge c
seek-lt b
set-bounds lower=b upper=c
seek-ge c
seek-lt b
set-bounds lower= upper=
seek-ge c
seek-lt b
----
                 seek-ge c: <c:3>:C
                 seek-lt b: <a:1>:A
set-bounds lower=b upper=c: .
                 seek-ge c: .
                 seek-lt b: .
  set-bounds lower= upper=: .
                 seek-ge c: <c:3>:C
                 seek-lt b: <a:1>:A

# Verify that seeking past the end of the sstable leaves the iterator
# in a state where prev returns the last key in the table.

iter
seek-lt d
seek-ge f
prev
----
seek-lt d: <c:3>:C
seek-ge f: .
     prev: <d:4>:D

# Verify that seeking before the beginning of the sstable leaves the
# iterator in a state where next returns the first key in the table.

iter
seek-ge b
seek-lt a
next
----
seek-ge b: <b:2>:B
seek-lt a: .
     next: <a:1>:A


# Verify the optimization to use next when doing SeekGE.

iter
seek-ge a
seek-ge a try-seek-using-next
seek-ge b try-seek-using-next
seek-ge c try-seek-using-next
seek-ge d try-seek-using-next
seek-ge e try-seek-using-next
----
strconv.ParseBool: parsing "try-seek-using-next": invalid syntax

# Verify the optimization to use next when doing SeekPrefixGE.

iter
seek-prefix-ge a
seek-prefix-ge a try-seek-using-next
seek-prefix-ge b try-seek-using-next
seek-prefix-ge c try-seek-using-next
seek-prefix-ge d try-seek-using-next
seek-prefix-ge e try-seek-using-next
----
strconv.ParseBool: parsing "try-seek-using-next": invalid syntax

# Verify that iteration from before the beginning or after the end of
# the sstable does not "wrap around". A bug previously allowed this to
# happen by letting the data block iterator and index iterator get out
# of sync.

build
a#1,SET:a
----

iter
first
prev
next
next
next
----
first: <a:1>:a
 prev: .
 next: <a:1>:a
 next: .
 next: .

iter
last
next
prev
prev
prev
----
last: <a:1>:a
next: .
prev: <a:1>:a
prev: .
prev: .

# Build a sufficiently large SST to enable two-level indexes.

build
a#1,SET:A
aae#1,SET:E
aaf#1,SET:F
aag#1,SET:G
aah#1,SET:H
aai#1,SET:I
aaj#1,SET:J
aak#1,SET:K
aal#1,SET:L
aam#1,SET:M
aan#1,SET:N
aao#1,SET:O
aap#1,SET:P
aaq#1,SET:Q
aar#1,SET:R
aas#1,SET:S
aat#1,SET:T
aau#1,SET:U
aav#1,SET:V
aaw#1,SET:W
aax#1,SET:X
aay#1,SET:Y
aaz#1,SET:Z
b#2,SET:B
bbe#2,SET:E
bbf#2,SET:F
bbg#2,SET:G
bbh#2,SET:H
bbi#2,SET:I
bbj#2,SET:J
bbk#2,SET:K
bbl#2,SET:L
bbm#2,SET:M
bbn#2,SET:N
bbo#2,SET:O
bbp#2,SET:P
bbq#2,SET:Q
bbr#2,SET:R
bbs#2,SET:S
bbt#2,SET:T
bbu#2,SET:U
bbv#2,SET:V
bbw#2,SET:W
bbx#2,SET:X
bby#2,SET:Y
bbz#2,SET:Z
c#3,SET:C
Span: cc-ccc:{(#3,RANGEDEL)}
cce#3,SET:E
ccf#3,SET:F
ccg#3,SET:G
cch#3,SET:H
cci#3,SET:I
ccj#3,SET:J
cck#3,SET:K
ccl#3,SET:L
ccm#3,SET:M
ccn#3,SET:N
cco#3,SET:O
ccp#3,SET:P
ccq#3,SET:Q
ccr#3,SET:R
ccs#3,SET:S
cct#3,SET:T
ccu#3,SET:U
ccv#3,SET:V
ccw#3,SET:W
ccx#3,SET:X
ccy#3,SET:Y
ccz#3,SET:Z
d#4,SET:D
Span: dd-ddd:{(#4,RANGEDEL)}
dde#4,SET:E
ddf#4,SET:F
ddg#4,SET:G
ddh#4,SET:H
ddi#4,SET:I
ddj#4,SET:J
ddk#4,SET:K
ddl#4,SET:L
ddm#4,SET:M
ddn#4,SET:N
ddo#4,SET:O
ddp#4,SET:P
ddq#4,SET:Q
ddr#4,SET:R
dds#4,SET:S
ddt#4,SET:T
ddu#4,SET:U
ddv#4,SET:V
ddw#4,SET:W
ddx#4,SET:X
ddy#4,SET:Y
ddz#4,SET:Z
----

iter
first
prev
next
next
next
next
next
----
first: <a:1>:A
 prev: .
 next: <a:1>:A
 next: <aae:1>:E
 next: <aaf:1>:F
 next: <aag:1>:G
 next: <aah:1>:H

iter
last
next
prev
prev
prev
----
last: <ddz:4>:Z
next: .
prev: <ddz:4>:Z
prev: <ddy:4>:Y
prev: <ddx:4>:X

iter
first
prev
next
next
seek-ge x
prev
prev
----
    first: <a:1>:A
     prev: .
     next: <a:1>:A
     next: <aae:1>:E
seek-ge x: .
     prev: <ddz:4>:Z
     prev: <ddy:4>:Y

iter
first
prev
next
next
seek-prefix-ge x
prev
prev
----
           first: <a:1>:A
            prev: .
            next: <a:1>:A
            next: <aae:1>:E
seek-prefix-ge x: .
            prev: .
            prev: .

iter
last
next
prev
prev
seek-lt a
next
next
----
     last: <ddz:4>:Z
     next: .
     prev: <ddz:4>:Z
     prev: <ddy:4>:Y
seek-lt a: .
     next: <a:1>:A
     next: <aae:1>:E

# Test that SeekPrefixGE does not position the iterator far outside the iterator bounds.
# Doing so would break the subsequent SeekGE that is utilizing the next instead of seek
# optimization.
iter
set-bounds lower=a upper=aae
seek-ge a
seek-prefix-ge aad
set-bounds lower=aae upper=b
seek-ge aae
next
----
set-bounds lower=a upper=aae: .
                   seek-ge a: <a:1>:A
          seek-prefix-ge aad: .
set-bounds lower=aae upper=b: .
                 seek-ge aae: <aae:1>:E
                        next: <aaf:1>:F

# Test that using Next does not mislead a twoLevelIterator into believing that the
# iterator has been positioned based on the latest iterator bounds. The Next call
# immediately after SetBounds has a non-deterministic result, hence we use
# next-ignore-result.
iter
set-bounds lower=bbq upper=d
seek-ge bbq
set-bounds lower=b upper=bbf
next-ignore-result
set-bounds lower=bbf upper=c
seek-ge bbf
next
----
set-bounds lower=bbq upper=d: .
                 seek-ge bbq: <bbq:2>:Q
set-bounds lower=b upper=bbf: .
          next-ignore-result: .
set-bounds lower=bbf upper=c: .
                 seek-ge bbf: <bbf:2>:F
                        next: <bbg:2>:G

build
a@10#10,SET:a10
a@5#5,SET:a5
b@20#20,SET:b20
b@17#17,SET:b17
c@30#30,SET:c30
d@40#40,SET:d40
----

iter
first
next
next
next
next
next
next
----
first: <a@10:10>:a10
 next: <a@5:5>:a5
 next: <b@20:20>:b20
 next: <b@17:17>:b17
 next: <c@30:30>:c30
 next: <d@40:40>:d40
 next: .

iter
seek-ge a@5
prev
seek-lt b
next
next
seek-lt c
prev
seek-ge b@18
prev
next
----
 seek-ge a@5: <a@5:5>:a5
        prev: <a@10:10>:a10
   seek-lt b: <a@5:5>:a5
        next: <b@20:20>:b20
        next: <b@17:17>:b17
   seek-lt c: <b@17:17>:b17
        prev: <b@20:20>:b20
seek-ge b@18: <b@17:17>:b17
        prev: <b@20:20>:b20
        next: <b@17:17>:b17

iter
seek-ge a@10
next-prefix
next-prefix
next-prefix
next-prefix
----
seek-ge a@10: <a@10:10>:a10
 next-prefix: <b@20:20>:b20
 next-prefix: <c@30:30>:c30
 next-prefix: <d@40:40>:d40
 next-prefix: .

build
a@10#10,SET:a10
a@5#5,SET:a5
a@3#3,DEL:
aa@30#10,SET:aa30
abcd@50#10,SET:abcd50
abcd@49#9,SET:abcd49
abcd@48#8,SET:abcd48
abcd@47#7,SET:abcd47
b@20#20,SET:b20
b@17#17,SET:b17
b@15#15,SET:b15
c#20,SET:c
c@90#18,SET:c90
d@70#16,SET:d70
----

iter
seek-ge a@10
next-prefix
next-prefix
next-prefix
next-prefix
next-prefix
next-prefix
----
seek-ge a@10: <a@10:10>:a10
 next-prefix: <aa@30:10>:aa30
 next-prefix: <abcd@50:10>:abcd50
 next-prefix: <b@20:20>:b20
 next-prefix: <c:20>:c
 next-prefix: <d@70:16>:d70
 next-prefix: .


build
a@49#49,SET:a49
a@48#48,SET:a48
a@47#47,SET:a47
a@46#46,SET:a46
a@45#45,SET:a45
a@44#44,SET:a44
a@43#43,SET:a43
a@42#42,SET:a42
a@41#41,SET:a41
a@40#40,SET:a40
a@39#39,SET:a39
a@38#38,SET:a38
a@37#37,SET:a37
a@36#36,SET:a36
a@35#35,SET:a35
a@34#34,SET:a34
a@33#33,SET:a33
a@32#32,SET:a32
a@31#31,SET:a31
a@30#30,SET:a30
a@29#29,SET:a29
a@28#28,SET:a28
a@27#27,SET:a27
a@26#26,SET:a26
a@25#25,SET:a25
a@24#24,SET:a24
a@23#23,SET:a23
a@22#22,SET:a22
a@21#21,SET:a21
a@20#20,SET:a20
a@19#19,SET:a19
a@18#18,SET:a18
a@17#17,SET:a17
a@16#16,SET:a16
a@15#15,SET:a15
a@14#14,SET:a14
a@13#13,SET:a13
a@12#12,SET:a12
a@11#11,SET:a11
a@10#10,SET:a10
b@20#20,SET:b20
----

iter
seek-ge a@49
next-prefix
next-prefix
seek-ge a@47
next-prefix
next-prefix
seek-ge a@36
next-prefix
next-prefix
seek-ge a@33
next-prefix
next-prefix
seek-ge a@30
next-prefix
next-prefix
seek-ge a@26
next-prefix
next-prefix
seek-ge a@20
next-prefix
next-prefix
seek-ge aa@10
next-prefix
----
 seek-ge a@49: <a@49:49>:a49
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@47: <a@47:47>:a47
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@36: <a@36:36>:a36
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@33: <a@33:33>:a33
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@30: <a@30:30>:a30
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@26: <a@26:26>:a26
  next-prefix: <b@20:20>:b20
  next-prefix: .
 seek-ge a@20: <a@20:20>:a20
  next-prefix: <b@20:20>:b20
  next-prefix: .
seek-ge aa@10: <b@20:20>:b20
  next-prefix: .
