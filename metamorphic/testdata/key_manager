# run subcommands
#
# add-new-key <key>
# keys
# singledel-keys <writerID>
# op <operation string as printed to ops files>

run
add-new-key foo
add-new-key foo
----
"foo" is new
"foo" already tracked

# Test SET; SINGLEDEL on DB.

run
keys
singledel-keys db1
singledel-keys batch1
op db1.Set("foo", "foo")
keys
singledel-keys db1
singledel-keys batch1
op db1.SingleDelete("foo", false)
keys
singledel-keys db1
----
keys: "foo"
can singledel on db1: "foo"
can singledel on batch1: "foo"
[db1.Set("foo", "foo")]
keys: "foo"
can singledel on db1: "foo"
can singledel on batch1: "foo"
[db1.SingleDelete("foo", false /* maybeReplaceDelete */)]
keys: "foo"
can singledel on db1: "foo"

# Test SET; SINGLEDEL on batch on separate key.

run
add-new-key bar
op batch1.Set("bar", "bar")
keys
singledel-keys db1
singledel-keys batch1
singledel-keys batch2
op batch1.SingleDelete("bar", false)
keys
singledel-keys db1
singledel-keys batch1
op db1.Apply(batch1)
singledel-keys db1
----
"bar" is new
[batch1.Set("bar", "bar")]
keys: "bar", "foo"
can singledel on db1: "bar", "foo"
can singledel on batch1: "bar", "foo"
can singledel on batch2: "bar", "foo"
[batch1.SingleDelete("bar", false /* maybeReplaceDelete */)]
keys: "bar", "foo"
can singledel on db1: "bar", "foo"
can singledel on batch1: "bar", "foo"
[db1.Apply(batch1)]
can singledel on db1: "bar", "foo"

# Test SET on db; SINGLEDEL on batch.

reset
----

run
add-new-key foo
op db1.Set("foo", "foo")
singledel-keys db1
singledel-keys batch1
op batch1.SingleDelete("foo", false)
singledel-keys db1
singledel-keys batch1
op db1.Apply(batch1)
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
singledel-keys batch1
----
"foo" is new
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
can singledel on batch1: "foo"
[batch1.SingleDelete("foo", false /* maybeReplaceDelete */)]
can singledel on db1: "foo"
can singledel on batch1: "foo"
[db1.Apply(batch1)]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
can singledel on batch1: "foo"

# Test SET; DEL; SET; SingleDelete on db.

reset
----

run
add-new-key foo
op db1.Set("foo", "foo")
op db1.Delete("foo")
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
op db1.SingleDelete("foo", false)
singledel-keys db1
----
"foo" is new
[db1.Set("foo", "foo")]
[db1.Delete("foo")]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
[db1.SingleDelete("foo", false /* maybeReplaceDelete */)]
can singledel on db1: "foo"

# Test SET; DEL; SET; DEL on batches.

reset
----

run
add-new-key foo
op batch1.Set("foo", "foo")
op batch1.Delete("foo")
op batch1.Set("foo", "foo")
singledel-keys batch1
op db1.Apply(batch1)
----
"foo" is new
[batch1.Set("foo", "foo")]
[batch1.Delete("foo")]
[batch1.Set("foo", "foo")]
can singledel on batch1: "foo"
[db1.Apply(batch1)]

# "foo" should be eligible for single delete on db1 because a Delete separates
# the two sets.

run
singledel-keys db1
----
can singledel on db1: "foo"

# A batch that contains its own Set and SingleDelete should conflict, because
# the two Sets would stack.

run
op batch2.Set("foo", "foo")
op batch2.SingleDelete("foo", false)
conflicts batch2 db1
----
[batch2.Set("foo", "foo")]
[batch2.SingleDelete("foo", false /* maybeReplaceDelete */)]
conflicts merging batch2 into db1: "foo"

# Setting "foo" again on the DB should result in the key no longer be eligible
# for single delete because there are two stacked SETs on db1.s

run
op db1.Set("foo", "foo")
singledel-keys db1
----
[db1.Set("foo", "foo")]
can singledel on db1: (none)

run
op batch2.Delete("foo")
op db1.Apply(batch2)
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
----
[batch2.Delete("foo")]
[db1.Apply(batch2)]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"

# Test SET; MERGE; DEL; SINGLEDEL on DB.

reset
----

run
add-new-key foo
op db.Set("foo", "foo")
singledel-keys db1
op db1.Merge("foo", "foo")
singledel-keys db1
op db1.Delete("foo")
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
op db1.SingleDelete("foo", false)
singledel-keys db1
----
"foo" is new
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
[db1.Merge("foo", "foo")]
can singledel on db1: (none)
[db1.Delete("foo")]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
[db1.SingleDelete("foo", false /* maybeReplaceDelete */)]
can singledel on db1: "foo"

# Test SET; DEL (db); SET; SINGLEDEL (batch)

reset
----

run
add-new-key foo
op db1.Set("foo", "foo")
singledel-keys db1
op db1.Delete("foo")
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
singledel-keys batch1
op batch1.SingleDelete("foo", false)
singledel-keys db1
singledel-keys batch1
op db1.Apply(batch1)
singledel-keys db1
op db1.Set("foo", "foo")
singledel-keys db1
----
"foo" is new
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
[db1.Delete("foo")]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"
can singledel on batch1: "foo"
[batch1.SingleDelete("foo", false /* maybeReplaceDelete */)]
can singledel on db1: "foo"
can singledel on batch1: "foo"
[db1.Apply(batch1)]
can singledel on db1: "foo"
[db1.Set("foo", "foo")]
can singledel on db1: "foo"

# A delete range should "reset" keys, even if the delete range is applied to a
# batch that doesn't yet contain the relevant key.

reset
----

run
add-new-key foo
add-new-key bar
op db1.Set("foo", "foo")
op db1.Set("foo", "foo")
singledel-keys db1
op batch1.DeleteRange("a", "z")
op db1.Apply(batch1)
singledel-keys db1
----
"foo" is new
"bar" is new
[db1.Set("foo", "foo")]
[db1.Set("foo", "foo")]
can singledel on db1: "bar"
[batch1.DeleteRange("a", "z")]
[db1.Apply(batch1)]
can singledel on db1: "bar", "foo"
